function sol(classes, grIndex) {
    this.gr = grIndex
    this.cl = new Array(5)
    for (var cla in classes) this.cl[cla] = classes[cla]
    //formula is: (baseBP+(40+gr)/1000*(level-1)), gr=0,1,2,3,4,5
    solBase = (base * 1000 + (40 + this.gr) * (level - 1)) / 1000
    this.BP = new Array(5)
    this.stat = new Array(5)
    this.loss = undefined
    this.cfLoss = new Array(0, 0, 0, 0, 0)
    this.maxLoss = new Array(5)
    for (var ba in this.cl) {
        this.BP[ba] = this.cl[ba] * solBase
        this.stat[ba] = stat(ba, this.cl) * solBase + 20
    }
    this.spi = spi(this.cl) * solBase + 100
    this.rev = rev(this.cl) * solBase + 100
    return this
}

//stats are stored with base 20 removed
//BP and rec/spi are optional, and checked against if inputed
//only integer values matter
function pt(values) {
    var vLen = values.length
    doCheckBP = false
    if (values[0] == undefined || vLen < 5) return this
    this.sols = new Array()
    this.stat = new Array(5)
    for (var j = 0; j < 5; j++) this.stat[j] = values[j] - 20
    if (vLen > 5 && vLen < 10) {
        this.spi = values[5]
        if (vLen > 6) this.rev = values[6]
        return this
    }
    //if length is  6, assume stat + spi
    //if length is  7, assume stat + spi + rev
    //if length is  8 or 9, only consider first 7
    //if length is 10, assume stat + BP,
    //if length is 11, assume stat + spi + BP (!!!could be stat + BP + BPSum!!)
    //could be stat+bp+ (-x~-x)
    //if length is 12, assume stat + spi + rev + BP(!!!could be stat + spi + BP + BPSum!!!)
    //could be stat+bp+ (-x~-x)
    //if length is 13, assume stat + spi + rev + BP + BPSum
    //if length is over 12, only consider first 12
    //move can be calculated by -10 from vLen, then set max to 2
    if (vLen >= 10) {
        doCheckBP = true
        var move = Math.min(vLen - 10, 2) + 5
        if (vLen == 11 || vLen == 12) {
            //assumed values[5] is spi, now check assumption (move is now 6)
            //assumption is WRONG if last number equates to sum of the 5 numbers before it
            var sum = 0
            for (var j = (vLen - 6); j < (vLen - 1); j++) sum += values[move + j]
            if (sum == values[vLen - 1]) move--
            else if (values[5] > 20) {
                this.spi = values[5]
                if (vLen == 12) this.rev = values[6]
            } else {
                move -= (vLen - 10)
            }
        }
        if (vLen > 11 && values[5] > 20) this.spi = values[5]
        if (vLen > 12 && values[6] > 20) this.rev = values[6] //assume stat+spi+rev+BP+rubbish
        this.BP = new Array(5)
        for (var b = 0; b < 5; b++) this.BP[b] = values[b + move]
    }
    return this
}


// here starts some horrible programming
// re:
// 0 is stat given
// 1 indicate whether solution exist
// 2 is lossMin
// 3 is lossMax
// 4 is cfLossSummary
// 5 is maxLossSummary
// 6 is array of cor solutions
// 6[a][0][0~4] is class for solution a
// 6[a][1] is total loss for solution a
// 6[a][2][0~4] is cfLoss for solution a
// 6[a][3][0~4] is maxLoss for solution a

var o = "" //output of calculation

//Pts格式為 (圖鑑編號,寵物名,種族編號,體頂檔,力頂檔,強頂檔,速頂檔,魔頂檔,屬性,屬性量,卡色,卡等,技能欄,出沒地點,一級點,出現率[分鐘],可否封印)
//          (  Pts[0],   [1],     [2],   [3],   [4],   [5],   [6],   [7], [8],   [9],[10],[11],  [12],    [13],  [14],        [15],    [16])
//寵物名: 如標明(缺), 表示檔次資料不齊, 無法正確計算
//卡色: G=金, S=銀, N=普
//屬性: A=地水,B=水火,C=火風,D=風地  例:A9=地9水1, D10=風10
//      X=特殊屬性(地水火風)         例:X2222=地2水2火2風2, X505=水5風5, 注意: 必須省略起始的0, 例: 不可以有X0505
//卡色,卡等,出沒地點,一級點,出現率: X=不適用, ?=未知
//可否封印: Y/N
Pts = new Array(
    new Array(1, "虎人", 0, 22, 26, 17, 19, 16, "D", 7, "N", 2, 8, "謎之迷宮11~16,里歐波多洞窟20~24,風之洞窟26~31,動物實驗室65,迷龍之巢29~31", "動物實驗室(108,94)(118,97)", 10, "Y"),
    new Array(2, "貓妖", 0, 19, 24, 17, 28, 17, "B", 7, "N", 2, 9, "謎之迷宮11~16,水之洞窟54~61,動物實驗室65", "動物實驗室(112,107)", 10, "Y"),
    new Array(3, "羅剎", 0, 24, 25, 14, 22, 20, "B", 3, "S", 3, 9, "詛咒的迷宮地下11~20樓41~43,炎之洞窟40~50", "詛咒的迷宮地下13樓(25,5)", 45, "Y"),
    new Array(4, "貓人", 0, 23, 27, 15, 26, 14, "D", 5, "S", 3, 9, "風之洞窟26~31,迷龍之巢29~34,莎蓮娜東邊洞窟35~37", "莎蓮娜東邊洞窟地下2樓(12,16)", 90, "Y"),
    new Array(5, "惡魔貓", 0, 21, 23, 12, 27, 22, "D", 3, "S", 3, 9, "阿巴尼斯洞窟34~36", "阿巴尼斯洞窟傑村側1樓(15,15)", 50, "Y"),
    new Array(6, "妖狐", 0, 18, 30, 11, 25, 26, "B", 5, "S", 4, 8, "冰之洞窟57~59", "冰之洞窟二樓(16,24)", 120, "Y"),
    new Array(7, "穴熊", 0, 34, 34, 19, 19, 14, "A", 8, "N", 3, 6, "維諾亞洞窟16~18", "維諾亞洞窟全域", 20, "Y"),
    new Array(8, "赤熊", 0, 35, 36, 15, 20, 14, "C", 8, "N", 5, 6, "尼維爾海村周圍10~13", "尼維爾海村附近 (515,469)(510,470)", 70, "Y"),
    new Array(9, "北極熊", 0, 36, 33, 22, 18, 11, "A", 2, "N", 5, 6, "阿巴尼斯村周圍31~33", "阿巴尼斯村外(255,182)(256,191)", 40, "Y"),
    new Array(10, "赤目黑熊", 0, 33, 35, 14, 22, 16, "C", 2, "S", 6, 6, "參道33~35,伊姆爾森林68~70", "X", "X", "Y"),
    new Array(11, "貓熊", 0, 32, 40, 18, 17, 18, "B", 5, "G", 7, 7, "X", "火焰鼠彩卷B獎", "X", "Y"),
    new Array(12, "大地鼠", 0, 6, 13, 20, 26, 35, "A", 10, "N", 1, 10, "聖拉魯卡域4~6,流星山丘18~20,一勳遺跡75", "聖拉魯卡村外(235,203)(149,219)", 10, "Y"),
    new Array(13, "惡夢鼠", 0, 4, 8, 18, 33, 37, "B", 10, "S", 2, 10, "青龍的洞窟23~25,王族的通道49,一勳遺跡75", "五勳任務的王族用脫逃暗道 東方(30,40)", "?", "Y"),
    new Array(14, "火焰鼠", 0, 7, 12, 15, 34, 32, "C", 10, "N", 1, 10, "奇利村周邊15~17,流星山丘18~20,尼維爾海域,炎之洞窟39~47,一勳遺跡75", "奇利村外(230,330)(235,326)", 15, "Y"),
    new Array(15, "寶石鼠", 0, 7, 7, 22, 27, 37, "D", 10, "S", 2, 10, "鏡中豪宅21~24,一勳遺跡75", "鏡中豪宅一樓(24,6)(24,8)", 40, "Y"),
    new Array(16, "水藍鼠", 0, 11, 15, 28, 28, 33, "A", 5, "G", 6, 10, "X", "火焰鼠彩卷B獎", "X", "Y"),
    new Array(17, "鼠王", 0, 15, 7, 19, 32, 42, "C", 5, "G", 7, 10, "X", "鼠王驚奇蛋1等獎", "X", "Y"),
    new Array(18, "地獄看門犬", 0, 26, 36, 12, 23, 18, "B", 6, "N", 4, 7, "奇怪的洞窟16~19,里歐波多洞窟20~24,魯米那斯附近45~46", "亞留特村內(48,37),用Lv20以上地獄看門犬換", "X", "Y"),
    new Array(19, "巨狼", 0, 22, 37, 11, 25, 20, "A", 6, "N", 4, 7, "峽之洞窟42~47", "X", "X", "Y"),
    new Array(20, "地獄獵犬", 0, 24, 35, 19, 22, 15, "C", 6, "S", 5, 7, "哥拉爾城周邊12~14,詛咒的迷宮地下1~10樓38~40,炎之洞窟40~50", "詛咒的迷宮地下4樓(13,11)(16,11)", 90, "Y"),
    new Array(21, "地獄妖犬", 0, 23, 40, 13, 21, 18, "D", 6, "S", 5, 7, "積雪的山道39~45,貝茲雷姆神殿附近25~27,雷克塔爾村北側48~49", "傑諾瓦近郊的貝茲雷姆迷宮附近(121,315)(118,323)", 50, "Y"),
    new Array(22, "殭屍", 1, 37, 32, 12, 12, 12, "D", 6, "N", 2, 9, "暗醫躲藏的家6~9,暖爐底13~15,奇怪洞窟16~19,暗醫洞窟17~23,阿魯巴斯洞窟20~23,翠格墓園23~24,黑暗之巢27~30,庫魯克斯島(701.695)魔導研究塔64", "阿魯巴斯研究所最上層", 5, "Y"),
    new Array(23, "喪屍", 1, 35, 34, 7, 15, 14, "B", 6, "S", 3, 9, "積雪的山道39~45,黑暗之巢27~30,庫魯克斯島(701.695)魔導研究塔64", "雪山山頂(21,16)", 90, "Y"),
    new Array(24, "食屍鬼", 1, 32, 32, 17, 7, 17, "C", 6, "N", 2, 9, "阿魯巴斯洞窟20~23,黑暗之巢27~30,庫魯克斯島(701.695)魔導研究塔64", "阿魯巴斯研究所最上層", 5, "Y"),
    new Array(25, "腐屍", 1, 42, 37, 12, 7, 7, "A", 6, "N", 2, 9, "黑暗醫生躲藏的家10,奇怪的洞窟16~19,黑暗醫生洞窟18~23,阿魯巴斯洞窟20~23,黑暗之巢27~30,庫魯克斯島(701.695)魔導研究塔64", "阿魯巴斯研究所最上層", 5, "Y"),
    new Array(26, "木乃伊", 1, 39, 32, 14, 8, 17, "C", 5, "S", 4, 8, "沙漠之祠25~31,黑暗之巢28~30,,庫魯克斯島(701.695)魔導研究塔64,伊姆爾森林68~73", "沙漠祠堂第7層(13,25)", 30, "Y"),
    new Array(27, "骷髏戰士", 1, 12, 27, 42, 12, 17, "D", 7, "N", 3, 8, "翠格墓園20~24,青龍的洞窟23~25,羅連斯研究塔22~24", "X", "X", "Y"),
    new Array(28, "血骷髏", 1, 13, 24, 41, 10, 22, "C", 7, "S", 4, 8, "夜之蒂娜村31~33", "夜之蒂娜村外的海賊海灣(16,32)", 110, "Y"),
    new Array(29, "地獄骷髏", 1, 14, 30, 40, 11, 15, "B", 7, "N", 3, 8, "沙塵洞窟24~29", "X", "X", "Y"),
    new Array(30, "武裝骷髏", 1, 9, 26, 47, 8, 20, "A", 7, "S", 4, 8, "南恰拉山第2通道21~23,聖壇男路線36~38", "聖壇男路線第2層(63,5)", 100, "Y"),
    new Array(31, "骷髏海盜", 1, 12, 29, 45, 13, 16, "A", 5, "N", 3, 8, "伊姆爾森林68~73", "X", "X", "Y"),
    new Array(32, "幽靈", 1, 19, 18, 31, 20, 27, "A", 2, "N", 3, 7, "地下迷宮9~16,暖爐之底13~15,,翠格墓園21~24,詛咒的迷宮地下41~50樓50~52", "詛咒的迷宮地下41樓(7,6)(7,8)(8,5)", 50, "Y"),
    new Array(33, "鬼靈", 1, 9, 21, 27, 25, 33, "C", 8, "S", 5, 7, "黑色祈禱19~20,南恰拉山第1通道18~22,峽之洞窟42~47", "峽之洞窟(74,4)(74,5)需打贏地縛靈", "?", "Y"),
    new Array(34, "亡靈", 1, 14, 27, 30, 15
:,
29, "C", 2, "S", 5, 7, "聖壇女路線36~38", "聖壇女路線第2層(74,88)", 100, "Y"
),
new Array(35, "死靈", 1, 10, 28, 32, 17, 28, "A", 8, "N", 4, 7, "夜之蒂娜村31~33", "夜之蒂娜村(64,53)(33,26)(20,64)(53,48)", 300, "Y"),
    new Array(36, "小石像怪", 2, 16, 21, 11, 31, 26, "A", 5, "N", 1, 9, "靈堂1~2,米諾基亞村周邊46~47", "靈堂全域", 5, "Y"),
    new Array(37, "使魔", 2, 21, 20, 15, 27, 27, "C", 7, "N", 2, 9, "X", "完成國民任務後隨機取得", "X", "Y"),
    new Array(38, "水藍鳥魔", 2, 22, 23, 10, 25, 25, "A", 3, "S", 3, 9, "鏡中豪宅21~24,哥拉爾城周邊11~13,水之洞窟54~61", "鏡中豪宅2樓(40,25)", 60, "Y"),
    new Array(39, "小惡魔", 2, 21, 20, 9, 25, 30, "D", 3, "N", 2, 9, "亞諾曼城周邊5~10,土之洞窟12~16,奇利村周邊15~17,羽音洞窟30~34", "奇利村附近(280,400)", 30, "Y"),
    new Array(40, "迷你石像怪", 2, 23, 19, 10, 24, 29, "C", 3, "S", 3, 9, "阿凱魯法外11~13,風之洞窟26~31,詔三47~49,迷龍之巢29~34", "詛咒的迷宮地下35樓(18,5)(18,8)", 60, "Y"),
    new Array(41, "丘比特", 2, 12, 22, 7, 37, 37, "C", 5, "G", 7, 9, "X", "火焰鼠彩卷B獎", "X", "Y"),
    new Array(42, "石像怪", 2, 14, 30, 32, 22, 22, "D", 1, "S", 6, 6, "黑白龍城67~70,祭壇2~60", "X", "X", "Y"),
    new Array(43, "血魔", 2, 13, 31, 26, 25, 25, "B", 1, "N", 6, 6, "黑白龍城67~70,祭壇2~60", "X", "X", "Y"),
    new Array(44, "墮天使", 2, 11, 28, 28, 27, 26, "A", 1, "S", 6, 6, "冰雪的牢城60~62,黑白龍城67~70,祭壇2~60", "X", "X", "Y"),
    new Array(45, "惡魔", 2, 10, 27, 26, 26, 31, "C", 1, "N", 5, 6, "冰雪的牢城60~62,黑白龍城67~70,祭壇2~60", "X", "X", "Y"),
    new Array(46, "小蝙蝠", 2, 11, 26, 16, 31, 21, "A", 6, "N", 2, 10, "亞諾曼城周邊8~10", "完成國民任務後隨機取得", "X", "Y"),
    new Array(47, "掃把蝙蝠", 2, 13, 28, 12, 29, 18, "B", 6, "S", 2, 10, "莎蓮娜東邊洞窟35~37", "莎蓮娜東邊洞窟第二個地下二樓(18,25)", 60, "Y"),
    new Array(48, "迷你蝙蝠", 2, 11, 26, 20, 27, 16, "C", 6, "N", 1, 10, "法蘭城周邊1~5,競技場迷宮7~9,聖拉魯卡域3~5,炎之洞窟39~47,法蘭城門外1~2", "法蘭周邊/炎之洞窟外", 5, "Y"),
    new Array(49, "水果蝙蝠", 2, 17, 25, 15, 26, 17, "D", 6, "S", 2, 10, "霞之洞窟3~14,里歐波多洞窟20~24,魯米那斯附近45~46", "X", "X", "Y"),
    new Array(50, "惡魔蝙蝠", 2, 13, 34, 10, 29, 24, "B", 8, "G", 7, 10, "X", "黑龍城任務報酬", "X", "Y"),
    new Array(51, "天使蝙蝠", 2, 9, 22, 12, 37, 30, "D", 8, "G", 7, 10, "X", "白龍城任務報酬", "X", "Y"),
    new Array(52, "大蝙蝠", 2, 23, 28, 23, 28, 13, "A", 7, "N", 2, 7, "試煉洞窟1~4,黑暗醫生躲藏的家6~9,競技場迷宮7~9,黑暗醫生洞窟18~21,峽之洞窟46~50", "試煉洞窟1,2樓全域", 5, "Y"),
    new Array(53, "巨蝙蝠", 2, 27, 30, 22, 24, 12, "C", 3, "N", 3, 7, "佈滿青苔的洞窟17~19,青龍的洞窟26~27", "青龍的洞窟第4層(71,68)(72,66)", 60, "Y"),
    new Array(54, "海蝙蝠", 2, 18, 29, 27, 30, 11, "A", 3, "N", 4, 7, "海賊的洞窟13~15,地底湖17~19,雷克塔爾村南側48,羽音洞窟30~34", "地底湖地下2樓(42,60)(40,61)(44,60)(45,60)", 30, "Y"),
    new Array(55, "胖蝙蝠", 2, 25, 24, 20, 26, 20, "C", 7, "S", 5, 7, "阿巴尼斯洞窟34~36", "莎蓮娜西方洞窟阿村側1樓(30,46)(29,44)", 60, "Y"),
    new Array(56, "兔耳蝙蝠", 2, 21, 26, 18, 31, 14, "B", 5, "S", 4, 8, "蒂娜村周邊29~31", "蒂娜村附近(481,255)", 240, "Y"),
    new Array(57, "藍蠍", 3, 20, 27, 47, 13, 8, "B", 9, "S", 5, 7, "索奇亞沙漠21~22", "加納沙漠(582,327)", 60, "Y"),
    new Array(58, "紅蠍", 3, 19, 28, 42, 19, 7, "C", 9, "N", 4, 7, "鯰魚洞窟23~25", "鯰魚洞窟地下第3層(26,17)(32,17)", 50, "Y"),
    new Array(59, "黃蠍", 3, 20, 30, 43, 12, 10, "D", 9, "S", 5, 7, "索奇亞沙漠20~22", "加納沙漠(525,348)(544,341)(539,346)", 150, "Y"),
    new Array(60, "殺手蠍", 3, 30, 29, 38, 11, 7, "A", 9, "N", 4, 7, "沙漠之祠25~31", "沙漠之祠第8層(17,11)(16,7)<a href='http://ajet.nsysu.edu.tw/~ks176/poor.jpg' target='_blank'><font color='#FFFFD8'>蒔</font></a>", 60, "Y"),
    new Array(61, "殺人蜂", 3, 12, 37, 12, 37, 12, "D", 5, "S", 4, 8, "米內葛爾島中部36~38", "米內葛爾島中部(447,356)需通過路霸", 60, "Y"),
    new Array(62, "異型蜂", 3, 14, 33, 11, 35, 17, "C", 5, "N", 3, 8, "維諾亞村周邊11~13,烏克蘭入口14~16,坎那貝拉村外42~44", "維諾亞村周邊(428,400)(405,380)(470,378)(514,382)", 20, "Y"),
    new Array(63, "虎頭蜂", 3, 13, 40, 8, 38, 11, "D", 3, "S", 4, 8, "烏克蘭入口14~16,雷姆爾山新道28~32,羽音洞窟30~34", "X", "X", "Y"),
    new Array(64, "黃蜂", 3, 10, 38, 13, 43, 6, "C", 7, "N", 2, 8, "伊爾村周邊6~8,風之洞窟30", "伊爾村附近(668,310)(672,284)(690,286)(666,223)", 15, "Y"),
    new Array(65, "死亡蜂", 3, 7, 39, 15, 41, 8, "B", 7, "S", 4, 8, "亞諾曼城周邊5~10,蒂娜村周邊26~28", "蒂娜村附近(284,372)(292,366)傑村後門過橋左轉", 120, "Y"),
    new Array(66, "螳螂", 3, 16, 44, 22, 27, 11, "D", 4, "N", 5, 6, "奇利村周邊16~18", "奇利村附近(292,214)", 15, "Y"),
    new Array(67, "殺人螳螂", 3, 12, 45, 20, 26, 17, "B", 4, "S", 6, 6, "亞諾曼城周邊5~8,布朗山30~71", "亞諾曼城東北方(297,244)", 120, "Y"),
    new Array(68, "赤目螳螂", 3, 14, 44, 19, 29, 14, "C", 4, "S", 6, 6, "亞諾曼城周邊5~12,風洞21~23,米諾基亞村周邊46~48,艾爾卡絲之家60", "洪恩大風穴(131,29)(126,28)近加納出口樓梯", 30, "Y"),
    new Array(69, "死灰螳螂", 3, 15, 40, 17, 33, 15, "B", 5, "S", 6, 6, "蒂娜村周邊28~29", "蒂娜村附近(454,328)(457,329)", 110, "Y"),
    new Array(70, "致命螳螂", 3, 20, 43, 18, 27, 12, "A", 4, "N", 5, 6, "井底道路18~20", "通往烏克蘭村的井底道路2樓(44,4)", 60, "Y"),
    new Array(71, "土蜘蛛", 3, 26, 15, 18, 23, 23, "A", 10, "N", 2, 9, "牛鬼的洞窟9~14,海賊指揮部6~10,聖村倉庫10~12,流星山丘18~20,哥拉爾城內(91.136)瓦吉之館的秘密通道56", "牛鬼討伐任務, 對戰鬼犬時會出現", "X", "Y"),
    new Array(72, "水蜘蛛", 3, 24, 16, 17, 20, 28, "B", 10, "S", 3, 9, "風洞21~23", "洪恩大風穴(9,31)(10,33)", 30, "Y"),
    new Array(73, "火蜘蛛", 3, 22, 22, 16, 25, 20, "C", 10, "N", 2, 9, "試煉洞窟1~4,哈洞7~9,聖村倉庫10~12,流星山丘18~20,哥拉爾城內(91.136)瓦吉之館的秘密通道56", "試煉洞窟5樓(22,14)", 10, "Y"),
    new Array(74, "風蜘蛛", 3, 25, 28, 15, 19, 18, "D", 10, "S", 3, 9, "迷路之穴5~9,沙塵洞窟24~29,風之洞窟30", "X", "X", "Y"),
    new Array(75, "樹精", 4, 32, 17, 32, 12, 17, "B", 4, "N", 2, 8, "伊爾村周邊6~8,德威特島戴克斯特山脈5~15,坎那貝拉村外42~44", "伊爾村附近(561,211)(563,200)(568,196)", 15, "Y"),
    new Array(76, "死亡樹精", 4, 28, 20, 37, 9, 16, "A", 6, "S", 4, 8, "蒂娜村周邊27~29", "蒂娜村附近(361,339)", 90, "Y"),
    new Array(77, "黃金樹精", 4, 38, 22, 28, 10, 17, "D", 6, "G", 7, 8, "X", "[黃金樹任務]持有20級以上快枯死的樹精在流星山丘３００Ｍ西邊下山出山丘的飼養師寄宿所(148,199)與飼養師傅換得(限寵物系)", "X", "Y"),
    new Array(78, "慘白樹精", 4, 29, 16, 28, 17, 20, "C", 3, "S", 4, 8, "德威特島戴克斯特山脈6~15,蒂娜村周邊26~30", "蒂娜村附近(570,240)(559,246)", 60, "Y"),
    new Array(79, "冰冷樹精", 4, 30, 15, 27, 16, 22, "B", 7, "N", 3, 8, "亞留特村周邊10~13,奴克冰原12~15", "亞留特村附近(579,44)(685,156)", 10, "Y"),
    new Array(80, "沼澤樹精", 4, 31, 14, 29, 15, 21, "A", 7, "S", 4, 8, "阿凱魯法村附近12~14", "米內葛爾島(171,385)", 50, "Y"),
    new Array(81, "妖草", 4, 26, 11, 16, 16, 36, "A", 8, "N", 2, 9, "維諾亞村周邊11~13,土之洞窟12~16,米內葛爾島中部36~38", "維諾亞村周邊(422,357)(471,395)(490,392)", 25, "Y"),
    new Array(82, "蔓陀羅草", 4, 25, 13, 14, 15, 38, "D", 5, "S", 3, 9, "傑諾瓦村周邊23~25,布朗山30~71", "傑諾瓦村附近(280,488)(281,489)", 45, "Y"),
    new Array(83, "妖花", 4, 27, 12, 12, 19, 35, "C", 5, "S", 3, 9, "X", "再生花園任務報酬", "X", "Y"),
    new Array(84, "人魔草", 4, 22, 17, 11, 14, 41, "B", 8, "S", 3, 9, "參道33~35", "X", "X", "Y"),
    new Array(85, "綠色口臭鬼", 4, 38, 23, 16, 15, 23, "D", 1, "N", 4, 7, "莎蓮娜海底24~26,米內葛爾島中部35~37", "莎蓮娜海底1樓芙蕾雅側(9,12)(10,10)(10,13)", 60, "Y"),
    new Array(86, "黃色口臭鬼", 4, 37, 27, 18, 11, 22, "D", 9, "N", 4, 7, "維諾亞村周邊11~14,阿凱魯法村附近12~14", "維諾亞村周邊(346,514)(371,446)(394,512)(416,564)", 20, "Y"),
    new Array(87, "藍色口臭鬼", 4, 35, 25, 15, 18, 27, "B", 9, "S", 5, 7, "鯰魚內25~27,亞諾曼城周邊5~8,米內葛爾島中部36~38", "鯰魚洞窟胃袋(53,43)鯰魚大王胃袋(59,41)", 60, "Y"),
    new Array(88, "紅色口臭鬼", 4, 44, 21, 14, 12, 29, "B", 1, "N", 4, 7, "尼維爾村周邊(??),大樹66~67", "尼維爾海村以西(460,350)以及[5等勳章任務]大樹1F(27,5)", 25, "Y"),
    new Array(89, "兇暴仙人掌", 4, 27, 29, 22, 12, 20, "D", 5, "N", 3, 8, "詛咒的迷宮地下41~50樓50~52", "詛咒的迷宮地下41樓(10,20)", 60, "Y"),
    new Array(90, "武術仙人掌", 4, 24, 32, 27, 10, 17, "A", 5, "S", 4, 8, "索奇亞沙漠19~21", "加納沙漠(546,407)(561,401)", 60, "Y"),
    new Array(91, "兔耳仙人掌", 4, 28, 35, 19, 14, 14, "C", 5, "S", 4, 8, "索奇亞沙漠19~21", "加納沙漠(627,302)(634,296)", 40, "Y"),
    new Array(92, "印地安仙人掌", 4, 26, 36, 24, 9, 15, "B", 5, "N", 3, 8, "奇利村周邊16~18", "奇利村附近(306,329)(341,316)(343,312)(345,314)", 60, "Y"),
    new Array(93, "火焰舞者", 4, 19, 38, 18, 15, 25, "B", 2, "G", 5, 8, "X", "鯰魚大王任務報酬", "X", "Y"),
    new Array(94, "史萊姆", 5, 46, 26, 11, 6, 16, "D", 1, "N", 1, 9, "哈洞7~9,暖爐之底13~15,佈滿青苔的洞窟17~20,科學家的牢房19~21,忍者之家16~18", "法蘭城龜裂的地下道全域", 5, "Y"),
    new Array(95, "液態史萊姆", 5, 49, 24, 15, 5, 12, "A", 1, "N", 2, 9, "迷路之穴5~9,庫魯克斯島(349.592)紳士淑女養成學校的訓練設施11~13,科學家的牢房19~21", "法蘭城龜裂的地下道地圖上的NPC", "X", "Y"),
    new Array(96, "果凍史萊姆", 5, 45, 31, 6, 10, 13, "B", 1, "S", 3, 9, "科學家的牢房19~21,忍者之家16~18,莎蓮娜海底24~26,奇怪的坑道26~30,炎之洞窟39~47", "莎蓮娜海底通道一樓傑村側(7,8)", 40, "Y"),
    new Array(97, "布丁史萊姆", 5, 40, 25, 12, 8, 20, "C", 1, "S", 3, 9, "科學家的牢房19~21,鯰魚內25~27,王族的通道49", "鯰魚大王胃袋(第一層)(97,84)", 45, "Y"),
    new Array(98, "火精", 5, 25, 25, 25, 25, 25, "C", 10, "G", 6, 9, "X", "火焰鼠彩卷A獎", "X", "Y"),
    new Array(99, "風精", 5, 25, 25, 25, 25, 25, "D", 10, "G", 6, 9, "X", "火焰鼠彩卷A獎", "X", "Y"),
    new Array(100, "水精", 5, 25, 25, 25, 25, 25, "B", 10, "G", 6, 9, "X", "火焰鼠彩卷A獎", "X", "Y"),
    new Array(101, "地精", 5, 25, 25, 25, 25, 25, "A", 10, "G", 6, 9, "X", "火焰鼠彩卷A獎", "X", "Y"),
    new Array(102, "頑皮炸彈", 5, 15, 15, 15, 15, 40, "A", 8, "N", 1, 10, "土之洞窟12~16,南恰拉山第1通道18~22", "南恰拉山第1通道1樓(29,5)(30,7)(33,5)(35,5)", 60, "Y"),
    new Array(103, "寶貝炸彈", 5, 14, 17, 11, 16, 42, "B", 8, "S", 2, 10, "霞之洞窟3~14,里歐波多洞窟20~24,詛咒的迷宮地下31~40樓", "詛咒的迷宮地下36樓(22,5)", 60, "Y"),
    new Array(104, "大炸彈", 5, 12, 20, 14, 14, 40, "C", 8, "S", 2, 10, "貝茲雷姆迷宮34~36,魯米那斯附近47~48", "X", "X", "Y"),
    new Array(105, "漂浮炸彈", 5, 16, 14, 14, 17, 39, "D", 8, "N", 1, 10, "競技場迷宮7~9,地下迷宮9~16,風之洞窟26~31,迷龍之巢29~34", "法蘭城內競技場迷宮第一地圖(53,43)(已關閉)", "X", "Y"),
    new Array(106, "丸子炸彈", 5, 17, 17, 7, 17, 47, "D", 5, "G", 6, 10, "X", "火焰鼠彩卷B獎", "X", "Y"),
    new Array(107, "幻影", 5, 20, 26, 25, 17, 32, "C", 10, "N", 6, 6, "佛利波羅島56~58,冰雪的牢城56~57,阿卡斯島56~58,風鳴之塔56~57,六曜之塔56~57", "X", "X", "N"),
    new Array(108, "旋律影子", 5, 24, 28, 22, 19, 27, "B", 10, "N", 6, 6, "佛利波羅島56~58,冰雪的牢城56~57,阿卡斯島56~58,風鳴之塔56~57,六曜之塔56~58", "X", "X", "N"),
    new Array(109, "闇影", 5, 25, 23, 23, 23, 26, "D", 10, "N", 6, 6, "佛利波羅島56~58,冰雪的牢城56~57,阿卡斯島56~58,風鳴之塔56~57,六曜之塔56~59", "X", "X", "N"),
    new Array(110, "陰影", 5, 28, 24, 22, 22, 24, "A", 10, "N", 6, 6, "佛利波羅島56~58,冰雪的牢城56~57,阿卡斯島56~58,風鳴之塔56~57,六曜之塔56~60", "X", "X", "N"),
    new Array(111, "血腥之刃", 6, 9, 39, 34, 14, 24, "A", 9, "S", 6, 6, "黑色祈禱19~20,詛咒的迷宮地下11~20樓41~43", "詛咒的迷宮地下18樓(22,12)", 90, "Y"),
    new Array(112, "殺龍之刃", 6, 17, 37, 41, 11, 19, "B", 9, "N", 5, 6, "六曜之塔63~65", "X", "X", "Y"),
    new Array(113, "火焰之刃", 6, 10, 39, 28, 12, 31, "C", 9, "N", 5, 6, "聖壇男路線36~38", "聖壇男路線第3層(17,16)(18,19)", 150, "Y"),
    new Array(114, "烈風之刃", 6, 12, 44, 29, 13, 27, "D", 9, "S", 6, 6, "六曜之塔63~65", "X", "X", "Y"),
    new Array(115, "嚇人箱", 6, 11, 26, 26, 11, 31, "C", 2, "N", 2, 9, "寶箱中隨機出現(高機率於黑色寶箱中出現)", "收穫季豐收寶窟/黃金迷宮(寶箱中隨機出現,皆時效性活動)", "X", "Y"),
    new Array(116, "兔耳嚇人箱", 6, 9, 24, 23, 16, 33, "B", 2, "N", 2, 9, "寶箱中隨機出現(高機率於黑色寶箱中出現)", "收穫季豐收寶窟/黃金迷宮(寶箱中隨機出現,皆時效性活動)", "X", "Y"),
    new Array(117, "紅魔嚇人箱", 6, 12, 32, 27, 12, 27, "B", 5, "N", 3, 8, "寶箱中隨機出現", "收穫季豐收寶窟/黃金迷宮(寶箱中隨機出現,皆時效性活動)", "X", "Y"),
    new Array(118, "藍魔嚇人箱", 6, 15, 37, 28, 8, 22, "A", 2, "N", 3, 8, "寶箱中隨機出現", "收穫季豐收寶窟/黃金迷宮(寶箱中隨機出現,皆時效性活動)", "X", "Y"),
    new Array(119, "綠蛙嚇人箱", 6, 13, 35, 29, 10, 23, "D", 2, "N", 3, 8, "寶箱中隨機出現", "收穫季豐收寶窟/黃金迷宮(寶箱中隨機出現,皆時效性活動)", "X", "Y"),
    new Array(120, "純白嚇人箱", 6, 9, 24, 29, 11, 37, "D", 5, "S", 7, 9, "寶箱中隨機出現", "收穫季豐收寶窟/黃金迷宮(寶箱中隨機出現,皆時效性活動)", "X", "Y"),
    new Array(121, "冰怪", 6, 20, 30, 46, 7, 12, "B", 10, "N", 4, 7, "聖壇女路線36~38", "聖壇女路線第3層(134,85)(131,79)", 120, "Y"),
    new Array(122, "石怪", 6, 15, 38, 43, 6, 13, "A", 10, "N", 4, 7, "X", "[月亮俱樂部任務]第28天到芙蕾雅島魔女之家找馬梅達美對話後,至魔法陣中央使用珍妮給予的石像怪的製造方法", "X", "Y"),
    new Array(123, "銀怪", 6, 10, 32, 48, 8, 17, "C", 10, "N", 4, 7, "X", "在法蘭城冒險者旅館3F用三箱古錢交換(2970個古錢)", "X", "Y"),
    new Array(124, "金怪", 6, 14, 41, 40, 5, 15, "D", 10, "N", 4, 7, "X", "在法蘭城冒險者旅館3F用十箱古錢交換(9990個古錢)", "X", "Y"),
    new Array(125, "惡魔螃蟹", 6, 16, 32, 35, 11, 11, "B", 2, "N", 2, 9, "維諾亞洞窟16~18,誓約的海道32~34", "維諾亞洞窟1樓(42,66)", 25, "Y"),
    new Array(126, "水晶螃蟹", 6, 18, 31, 36, 10, 10, "B", 8, "N", 2, 9, "蒂娜村周邊29~31,水之洞窟54~61", "蒂娜村附近(517,238)", 120, "Y"),
    new Array(127, "鐵剪螃蟹", 6, 14, 34, 37, 12, 8, "D", 2, "S", 3, 9, "加納村周邊17~19,誓約的海道32~34,貝尼恰斯火山71~75", "加納村周邊(501,209)(462,205)", 100, "Y"),
    new Array(128, "黃金螃蟹", 6, 22, 30, 34, 7, 12, "D", 8, "S", 3, 9, "井底道路19~20,米內葛爾島中部37~39", "井底道路2樓(22,29)", 80, "Y"),
    new Array(129, "蜥蜴戰士", 7, 22, 32, 32, 12, 12, "D", 3, "N", 3, 8, "索奇亞海底18~20,維諾亞海底26~27,永久凍土54~63,咨詢60~64", "海底2層(8,47)", 60, "Y"),
    new Array(130, "蜥蜴鬥士", 7, 18, 37, 37, 8, 10, "A", 3, "S", 4, 8, "羅連斯研究塔21~23,詔二44~46,深淵54~63,咨詢60~64", "詛咒的迷宮地下22樓(17,10)", 60, "Y"),
    new Array(131, "蜥蝪武士", 7, 20, 31, 30, 15, 14, "B", 3, "N", 3, 8, "永久凍土54~63,咨詢60~64", "X", "X", "Y"),
    new Array(132, "獵豹蜥蜴", 7, 23, 36, 28, 10, 13, "C", 3, "S", 4, 8, "南恰拉山口13~15,詔二44~46,深淵54~63,咨詢60~64", "詛咒的迷宮地下29樓(12,12)", 60, "Y"),
    new Array(133, "大地翼龍", 7, 29, 28, 32, 20, 11, "A", 10, "S", 6, 6, "貝茲雷姆迷宮34~36,詛咒的迷宮地下1~10樓38~40,咨詢60~64", "詛咒的迷宮地下7樓(16,20)", 100, "Y"),
    new Array(134, "寒冰翼龍", 7, 30, 30, 31, 17, 12, "B", 10, "N", 5, 6, "青龍的洞窟26~28", "青龍的洞窟第4層(11,23)", 50, "Y"),
    new Array(135, "火焰翼龍", 7, 33, 33, 25, 16, 13, "C", 10, "N", 5, 6, "X", "[琥珀之卵6任務]打敗安潔可取得安潔可的逆十字,去蓋雷布倫森林找納塞對話", "X", "Y"),
new Array(136, "烈風翼龍", 7, 32, 30, 23, 20, 15, "D", 10, "S", 5, 6, "X", "X", "X", "Y"),
new Array(137, "翼龍", 7, 32, 30, 26, 19, 18, "B", 5, "G", "?", 6, "X", "X", "X", "Y"),
new Array(138, "地龍蜥", 7, 29, 34, 34, 15, 8, "A", 8, "N", 4, 7, "鯰魚洞窟23~25,深淵54~63,咨詢60~64", "鯰魚洞窟第3層(20,37)", 60, "Y"),
new Array(139, "水龍蜥", 7, 36, 38, 34, 11, 6, "B", 8, "N", 4, 7, "索奇亞海底18~20,維諾亞海底26~27,永久凍土54~63,咨詢60~64", "維諾亞海底洞窟第2層(49,8)", 35, "Y"),
new Array(140, "火龍蜥", 7, 32, 37, 37, 12, 7, "C", 8, "S", 5, 7, "峽之洞窟46~50,深淵54~63,咨詢60~64", "酒之殿堂外(765,48 )", 150, "Y"),
new Array(141, "風龍蜥", 7, 35, 35, 31, 10, 9, "D", 8, "S", 5, 7, "地底湖17~19,永久凍土54~63,咨詢60~64", "傑諾瓦村附近(145,522)", 60, "Y"),
new Array(142, "哥布林", 8, 27, 27, 27, 17, 7, "A", 7, "N", 1, 9, "法蘭城周邊1~5,哥布林之家3~12,牛鬼的洞窟9~13,里歐波多洞窟20~25", "法蘭城門外,牛鬼討伐任務對戰鬼犬時", 5, "Y"),
new Array(143, "紅帽哥布林", 8, 23, 30, 29, 20, 5, "B", 7, "N", 2, 9, "法蘭城周邊3~4,哥布林之家3~12,哥拉爾城周邊11~13,維諾亞村周邊11~14,里歐波多洞窟20~25", "維諾亞村周邊,牛鬼任務", "X", "Y"),
new Array(144, "火焰哥布林", 8, 22, 28, 26, 15, 14, "C", 7, "S", 3, 9, "牛鬼的洞窟9~13,傑諾瓦村周邊23~25,魯米那斯附近45~46", "傑諾瓦村附近(257,593)", 60, "Y"),
new Array(145, "烈風哥布林", 8, 30, 26, 24, 23, 4, "D", 7, "S", 3, 9, "奇怪的坑道26~30", "深淵地下水脈(44,56) ", "X", "Y"),
new Array(146, "巨人", 8, 38, 35, 24, 9, 14, "A", 10, "N", 5, 6, "風鳴之塔60~62", "風鳴之塔10樓(14,62)(15,62)", 50, "Y"),
new Array(147, "單眼巨人", 8, 34, 34, 20, 12, 20, "B", 10, "S", 6, 6, "X", "X", "X", "Y"),
new Array(148, "泰坦巨人", 8, 39, 30, 28, 8, 15, "D", 10, "S", 6, 6, "庫魯克斯島(349.592)紳士淑女養成學校的訓練設施11~13", "X", "X", "Y"),
new Array(149, "亞特拉斯巨神", 8, 37, 37, 17, 17, 12, "C", 10, "S", 6, 6, "風鳴之塔60~62", "風鳴之塔10樓(60,65)", 50, "Y"),
new Array(150, "盜賊", 8, 23, 28, 21, 31, 12, "C", 5, "N", 3, 7, "伊爾外1~9,聖拉魯卡域3~5,牛鬼的洞窟9~14,海賊的洞窟11~14,維諾亞周邊10~15,加納周邊18~21,奇利周邊17~19", "伊爾村近郊", "X", "N"),
new Array(151, "山賊", 8, 28, 27, 24, 26, 10, "D", 5, "N", 4, 7, "加納12~20,奇利17~19,奴克冰原14~22,地下遺跡45~49", "X", "X", "N"),
new Array(152, "海盜", 8, 19, 31, 23, 28, 14, "B", 5, "N", 4, 7, "海賊的洞窟11~14,加納村周邊18~20", "X", "X", "N"),
new Array(153, "破壞狂", 8, 27, 26, 30, 24, 8, "A", 5, "N", 4, 7, "奇怪的坑道26~31", "X", "X", "N"),
new Array(154, "鳥人", 8, 17, 17, 17, 37, 22, "D", 1, "N", 3, 8, "亞留特村周邊10~13,大樹66~67", "亞留特村附近(620,65)", 10, "Y"),
new Array(155, "幻歌妖", 8, 15, 18, 20, 38, 19, "A", 1, "S", 4, 8, "貝茲雷姆神殿附近25~27", "貝茲雷姆迷宮附近(80,346)", 60, "Y"),
new Array(156, "狠毒鳥人", 8, 18, 19, 14, 39, 20, "B", 1, "N", 3, 8, "亞諾曼城周邊5~8,加納村周邊17~19", "加納村周邊(473,387)", 60, "Y"),
new Array(157, "烈風鳥人", 8, 13, 20, 12, 42, 23, "C", 1, "S", 4, 8, "阿巴尼斯村周邊31~33", "阿巴尼斯村附近(56,163)", 120, "Y"),
new Array(158, "黑暗鳥人", 8, 19, 11, 11, 43, 31, "D", 5, "S", 4, 8, "冰之洞窟57~59", "冰之洞窟2樓(65,39)", 120, "Y"),
new Array(159, "山飛甲", 0, 27, 21, 15, 30, 27, "D", 4, "N", "?", 6, "X", "X", "X", "Y"),
new Array(160, "獨角獸", 0, 17, 25, 13, 28, 37, "A", 4, "S", "?", 6, "X", "一等勳艾國獎品", "X", "Y"),
new Array(161, "天馬", 0, 22, 22, 12, 32, 32, "B", 4, "N", "?", 6, "X", "一等勳艾國獎品", "X", "Y"),
new Array(162, "麒麟", 0, 19, 27, 10, 34, 30, "C", 4, "S", "?", 6, "X", "X", "X", "Y"),
new Array(163, "地底龜", 0, 22, 22, 37, 10, 19, "D", 5, "N", "?", 8, "X", "X", "X", "Y"),
new Array(164, "海底龜", 0, 23, 20, 45, 4, 18, "A", 5, "S", 4, 8, "坎那貝拉村外42~45", "庫魯克斯島坎那貝拉村西(447,320)", 50, "Y"),
new Array(165, "火焰龜", 0, 27, 17, 42, 7, 17, "B", 5, "N", 3, 8, "米內葛爾島中部35~37", "米內葛爾島中部(378,268)", 60, "Y"),
new Array(166, "硬殼龜", 0, 26, 16, 47, 5, 16, "C", 5, "S", 4, 8, "無人的洞窟", "X", "X", "Y"),
new Array(167, "鐮刀魔", 1, 23, 35, 18, 17, 32, "A", 10, "N", "?", 6, "X", "一等勳蘭國獎品", "X", "N"),
new Array(168, "暗黑僧侶", 1, 17, 37, 22, 12, 37, "B", 10, "S", 7, 6, "X", "X", "X", "N"),
new Array(169, "斬首者", 1, 19, 42, 20, 15, 29, "C", 10, "S", "?", 6, "X", "一等勳蘭國獎品", "X", "N"),
new Array(170, "冥界死神", 1, 25, 40, 12, 21, 27, "D", 10, "N", "?", 6, "X", "X", "X", "N"),
new Array(171, "牙骨", 1, 27, 32, 32, 12, 7, "D", 1, "N", "?", 8, "X", "X", "X", "Y"),
new Array(172, "顎牙", 1, 32, 29, 37, 7, 5, "A", 1, "S", 4, 8, "伊姆爾森林68~70", "X", "X", "Y"),
new Array(173, "巨牙", 1, 25, 30, 27, 17, 11, "B", 1, "N", 3, 8, "南恰拉山第2通道21~23", "南恰拉山第2通道1樓(9,23)", 90, "Y"),
new Array(174, "利牙", 1, 30, 37, 30, 9, 4, "C", 1, "S", "?", 8, "X", "X", "X", "Y"),
new Array(175, "獅鷲獸", 2, 22, 32, 12, 42, 17, "D", 4, "N", "?", 6, "X", "狩獵任務得到的蛋孵化出", "X", "Y"),
new Array(176, "變種獅鷲獸", 2, 26, 29, 15, 39, 16, "A", 4, "N", "?", 6, "X", "X", "X", "Y"),
new Array(177, "布雷歐", 2, 20, 34, 9, 47, 15, "B", 4, "S", "?", 6, "X", "X", "X", "Y"),
new Array(178, "依格羅斯", 2, 18, 36, 11, 44, 16, "C", 4, "S", "?", 6, "X", "X", "X", "Y"),
new Array(179, "托羅帝鳥", 2, 32, 20, 13, 35, 10, "D", 2, "N", 3, 8, "X", "X", "X", "Y"),
new Array(180, "岩地跑者", 2, 27, 22, 17, 32, 12, "A", 2, "S", 4, 8, "米內葛爾島中部37~39", "米內葛爾島中部(433,133) / 狩獵任務得到的蛋", 90, "Y"),
new Array(181, "火焰啄木鳥", 2, 22, 27, 19, 29, 13, "B", 2, "N", 3, 8, "雷姆爾山新道28~32", "X", "X", "Y"),
new Array(182, "狂奔鳥", 2, 25, 24, 18, 36, 7, "C", 2, "S", "?", 8, "X", "X", "X", "Y"),
new Array(183, "甲蟲", 3, 17, 37, 32, 12, 17, "A", 8, "N", 4, 7, "南恰拉山口13~15", "南恰拉山口(312,403)", 50, "Y"),
new Array(184, "掘地蟲", 3, 20, 35, 36, 8, 16, "B", 8, "S", 5, 7, "坎那貝拉村南部森林", "庫魯克斯島坎那貝拉村南(551,420)", 25, "Y"),
new Array(185, "鍬型蟲", 3, 15, 39, 29, 14, 18, "C", 8, "N", 5, 7, "麥尼的洞窟70~71", "麥尼的洞窟?", "X", "Y"),
new Array(186, "獨角仙", 3, 18, 41, 34, 9, 14, "D", 8, "S", 5, 7, "坎那貝拉村南部森林", "米內葛爾島中部小島(514,353)  ", "?", "Y"),
new Array(187, "翠綠菇", 4, 37, 12, 12, 17, 37, "D", 4, "S", 5, 7, "坎那貝拉村外42~44", "庫魯克斯島坎那貝拉村西(458,299)", 30, "Y"),
new Array(188, "水藍菇", 4, 38, 15, 13, 15, 34, "A", 4, "N", 4, 7, "阿凱魯法村附近11~13", "米內葛爾島(241,268)", 80, "Y"),
new Array(189, "粉紅菇", 4, 35, 10, 15, 14, 41, "B", 4, "N", 4, 7, "地下遺跡45~49", "小梅之間(10,17)", 90, "Y"),
new Array(190, "星菇", 4, 40, 13, 10, 13, 39, "C", 4, "S", 5, 7, "米內葛爾島中部36~38", "米內葛爾島中部(311,79)", 100, "Y"),
new Array(191, "綠煙", 5, 20, 20, 14, 25, 36, "D", 3, "N", "?", 7, "X", "X", "X", "Y"),
new Array(192, "煙霧", 5, 23, 23, 8, 30, 31, "A", 3, "N", 4, 7, "米諾基亞村周邊46~48,艾爾卡絲之家60", "米諾基亞村附近(616,834)", 20, "Y"),
new Array(193, "煙羅", 5, 22, 22, 12, 27, 32, "B", 3, "S", 5, 7, "貝尼恰斯火山71~75", "貝尼恰斯火山地下9樓(30,56)", 40, "Y"),
new Array(194, "棉球", 5, 25, 26, 9, 25, 30, "C", 3, "S", "?", 7, "X", "盲目之龍艾汀任務獎品 ", "X", "Y"),
new Array(195, "盾", 6, 15, 15, 45, 15, 30, "D", 4, "S", "?", 6, "X", "X", "X", "Y"),
new Array(196, "潛盾", 6, 17, 12, 47, 12, 32, "A", 4, "N", 5, 6, "哥拉爾城周邊12~14", "庫魯克斯島哥拉爾城附近(153,405)", 40, "Y"),
new Array(197, "強盾", 6, 19, 13, 49, 11, 28, "B", 4, "N", 5, 6, "魯米那斯附近45~46", "庫魯克斯島魯米那斯附近(364,606)", 30, "Y"),
new Array(198, "神盾", 6, 16, 9, 50, 8, 37, "C", 4, "S", 6, 6, "雷克塔爾村南側48", "庫魯克斯島(731,672)", 10, "Y"),
new Array(199, "岩怪", 6, 29, 22, 40, 5, 14, "A", 7, "S", 4, 8, "魯米那斯附近47~48,貝尼恰斯火山71~75", "庫魯克斯島貝尼恰斯火山域(500,632)", 20, "Y"),
new Array(200, "爆岩", 6, 30, 20, 42, 6, 12, "B", 7, "N", 3, 8, "伊利斯礦山", "伊利斯礦山大坑道(105,34)", 30, "Y"),
new Array(201, "熔岩", 6, 32, 17, 37, 7, 17, "C", 7, "S", 4, 8, "貝尼恰斯火山71~75", "貝尼恰斯火山2樓(59,44)", 60, "Y"),
new Array(202, "影岩", 6, 31, 15, 32, 12, 20, "D", 7, "N", 3, 8, "諾斯菲拉特59", "X", "X", "Y"),
new Array(203, "希特拉", 7, 42, 42, 27, 7, 7, "A", 6, "N", "?", 6, "詛咒者的洞窟(地)76", "X", "X", "Y"),
new Array(204, "蛟龍", 7, 40, 44, 25, 8, 8, "B", 6, "S", "?", 6, "詛咒者的洞窟(水)76", "X", "X", "Y"),
new Array(205, "埃及眼鏡蛇", 7, 38, 45, 30, 6, 6, "C", 6, "N", "?", 6, "詛咒者的洞窟(火)76", "X", "X", "Y"),
new Array(206, "八岐大蛇", 7, 46, 46, 23, 5, 5, "D", 6, "S", "?", 6, "X", "X", "X", "Y"),
new Array(207, "口袋龍", 7, 15, 34, 21, 20, 25, "D", 5, "N", 4, 7, "魯米那斯附近45~46", "庫魯克斯島魯米那斯附近(292,819)", 30, "Y"),
new Array(208, "迷你龍", 7, 10, 35, 23, 21, 26, "A", 5, "S", 5, 7, "X", "虛弱雛鳥任務的報酬", "X", "Y"),
new Array(209, "雛龍", 7, 12, 32, 22, 22, 27, "B", 5, "S", 5, 7, "弗利德島、皇后陵寢、雪拉威森塔", "皇后陵寢(58.45)(帶隊者身上須攜帶草葉彩苗)、到達方法參考任務：彩葉草之戀", "X", "Y"),
new Array(210, "穴龍", 7, 11, 31, 20, 25, 28, "C", 5, "N", 4, 7, "哥拉爾城周邊12~14", "庫魯克斯島哥拉爾城北(402,345)", 60, "Y"),
new Array(211, "大型半獸人", 8, 34, 25, 35, 10, 11, "A", 6, "N", 4, 7, "魯米那斯附近45~47", "庫魯克斯島魯米那斯附近(460,629)", 30, "Y"),
new Array(212, "豬鬼", 8, 33, 28, 33, 11, 10, "B", 6, "S", 5, 7, "雷克塔爾村北側48~49", "雷克塔爾村以西(383,265)", 20, "Y"),
new Array(213, "鋼鬼", 8, 30, 30, 30, 16, 9, "C", 6, "S", 5, 7, "米諾基亞村周邊46~47", "米諾基亞村東門外(549,838)", 20, "Y"),
new Array(214, "半獸人", 8, 32, 27, 32, 12, 12, "D", 6, "N", 4, 7, "哥拉爾城周邊11~13", "庫魯克斯島哥拉爾城周邊(425,453)", 60, "Y"),
new Array(215, "陸行鯊", 2, 29, 15, 36, 14, 9, "A", 3, "N", 2, 8, "法蘭城遺跡2~4,溫迪爾平原2~4", "法蘭城遺跡全域", "X", "Y"),
new Array(216, "沙地鯊(缺)", 2, 23, 13, 28, 23, 8, "B", 10, "N", "?", 10, "X", "X", "X", "N"),
new Array(217, "丘陵鯊(缺)", 2, 18, 8, 18, 33, 4, "B", 10, "N", "?", 10, "溫迪爾平原5~9", "X", "X", "N"),
new Array(218, "岩石鯊", 2, 27, 36, 7, 8, 25, "B", 10, "N", 3, 10, "布拉基姆高地30~34", "布拉基姆高地(148,138)附近(瀑布前方)", "?", "Y"),
new Array(219, "雛鳥", 2, 7, 8, 5, 38, 39, "D", 10, "G", 9, 10, "X", "X", "X", "Y"),
new Array(220, "鴨嘴獸(缺)", 2, 10, 23, 7, 23, 28, "B", 10, "G", 9, 10, "溫迪爾平原5~9", "X", "X", "Y"),
new Array(221, "小鴨子", 2, 8, 14, 7, 34, 28, "A", 10, "G", 9, 10, "溫迪爾平原2~4", "X", "X", "Y"),
new Array(222, "小兔子", 2, 11, 23, 7, 23, 28, "C", 10, "G", 9, 10, "X", "X", "X", "Y"),
new Array(223, "蛋白石怪(缺)", 6, 4, 8, 23, 4, 28, "A", 10, "N", "?", 10, "蓋雷布倫森林2~4,布拉基姆高地25~29", "X", "X", "N"),
new Array(224, "紅寶石怪(缺)", 6, 11, 23, 26, 6, 33, "A", 6, "N", 3, 10, "X", "X", "X", "Y"),
new Array(225, "岩蟲(缺)", 6, 28, 8, 23, 8, 23, "D", 2, "N", 4, 10, "布拉基姆高地40~45", "X", "X", "Y"),
new Array(226, "水晶怪(缺)", 6, 18, 8, 33, 4, 43, "A", 10, "G", 5, 10, "X", "X", "X", "N"),
new Array(227, "刀雞(缺)", 0, 4, 8, 4, 23, 8, "D", 10, "N", "?", 10, "蓋雷布倫森林10~14,布拉基姆高地25~29", "X", "X", "N"),
new Array(228, "劍鴕鳥(缺)", 0, 4, 18, 8, 23, 13, "D", 10, "N", "?", 10, "溫迪爾平原5~9", "X", "X", "N"),
new Array(229, "大刀鴯苗(缺)", 0, 7, 38, 8, 35, 21, "D", 10, "N", 3, 8, "布拉基姆高地30~34", "X", "X", "Y"),
new Array(230, "刀鋒阿姆鳥(缺)", 0, 4, 28, 8, 23, 23, "D", 10, "N", "?", 10, "L1恩‧凱迴廊2~4,L2恩‧凱迴廊10~14,L3恩‧凱迴廊20~24", "X", "X", "N"),
new Array(231, "火蜥蜴(缺)", 7, 33, 18, 18, 18, 28, "C", 10, "N", "?", 10, "L1阿陀羅迴廊2~4,L2阿陀羅迴廊10~14,L3阿陀羅迴廊20~24,盡頭的風穴75~79", "X", "X", "N"),
new Array(232, "毒蜥蜴(缺)", 7, 23, 8, 13, 8, 18, "A", 10, "N", "?", 10, "蓋雷布倫森林10~14,深草的綠洞43~49,怨靈的赤窟48~64", "X", "X", "N"),
new Array(233, "冰蜥蜴", 7, 26, 12, 33, 7, 27, "B", 10, "N", 3, 8, "罪之房1樓, L1花羅迴廊2~4,L2花羅迴廊10~14,L3花羅迴廊20~24", "罪之房1樓(131,51)", "?", "Y"),
new Array(234, "金屬蜥蜴(缺)", 7, 18, 8, 33, 4, 28, "A", 10, "S", 4, 7, "布拉基姆高地35~39", "X", "X", "Y"),
new Array(235, "戴靴怪", 3, 9, 9, 30, 26, 26, "A", 6, "N", 2, 8, "法蘭城遺跡2~4,L1威雷迴廊2~4,L2威雷迴廊10~14,L3威雷迴廊20~24", "X", "X", "Y"),
new Array(236, "舞靴怪(缺)", 3, 8, 13, 31, 35, 11, "C", 4, "N", 3, 8, "蓋雷布倫森林10~14,黑歷史之石洞20~27", "黑歷史之石洞4F(250.89)", "X", "Y"),
new Array(237, "潛靴怪(缺)", 3, 9, 25, 9, 34, 26, "D", 4, "N", 3, 8, "黑歷史之石洞20~27", "X", "X", "Y"),
new Array(238, "咚咚靴怪(缺)", 3, 4, 18, 23, 38, 8, "A", 10, "N", 3, 10, "布拉基姆高地30~34", "X", "X", "Y"),
new Array(239, "大公雞(缺)", 9, 4, 38, 4, 38, 48, "D", 10, "G", "?", 10, "法蘭城遺跡50,蓋雷布倫森林50,溫迪爾平原50", "X", "X", "N"),
new Array(240, "耶誕靴怪(缺)", 3, 7, 24, 13, 17, 7, "D", 10, "G", "?", 9, "X", "X", "X", "Y"),
new Array(241, "鑽石怪(缺)", 6, 31, 9, 23, 8, 25, "A", 10, "S", 3, 7, "布拉基姆高地30~34", "X", "X", "Y"),
new Array(242, "死神公雞", 9, 52, 52, 52, 52, 52, "B", 7, "G", "?", 10, "雪拉威森塔", "X", "X", "N"),
new Array(243, "銀獅", 0, 18, 42, 10, 32, 5, "C", 3, "S", 5, 5, "布拉基姆高地40~45", "布拉基姆高地(168,116)(171,117)附近(瀑布上方)", "X", "Y"),
new Array(244, "黃銅怪", 0, 32, 21, 10, 34, 18, "A", 7, "N", 2, 6, "X", "地之昏神的領域(146,143)(147,141)", "X", "Y"),
new Array(245, "鐵獅", 0, 19, 40, 11, 30, 5, "C", 10, "N", 3, 8, "罪之房38~40,盡頭的風穴75~79", "罪之房二層(128,55)", "?", "Y"),
new Array(246, "紅銅怪", 0, 27, 30, 13, 26, 19, "B", 7, "N", 2, 6, "X", "水之昏神的領域(167,101)(168,107)", "X", "Y"),
new Array(247, "跳跳地雷", 6, 31, 18, 16, 8, 33, "A", 10, "N", 3, 8, "罪之房38~40", "罪之房三層(209,224)", "?", "Y"),
new Array(248, "碎碎地雷", 6, 17, 27, 37, 7, 17, "C", 4, "N", 3, 8, "蟲洞29~34", "X", "X", "Y"),
new Array(249, "皮皮地雷(缺)", 6, 14, 30, 40, 7, 14, "A", 6, "S", 3, 7, "技能大師宴會任務密道", "技能大師宴會任務密道２Ｆ(77,108)附近", "X", "Y"),
new Array(250, "薩普地雷(缺)", 6, 13, 28, 38, 8, 23, "B", 4, "N", 4, 7, "深草的綠洞43~49,怨靈的赤窟48~64", "X", "X", "Y"),
new Array(251, "龍骨", 1, 7, 37, 12, 22, 27, "D", 5, "N", 3, 8, "布拉基姆高地30~34", "X", "X", "Y"),
new Array(252, "暗黑龍骨(缺)", 1, 4, 47, 11, 12, 27, "D", 2, "S", 3, 5, "技能大師宴會任務密道", "X", "X", "Y"),
new Array(253, "黃金龍骨", 1, 7, 42, 11, 12, 32, "D", 5, "S", 4, 6, "布拉基姆高地35~39", "布拉基姆高地(236,224)附近(挖掘鐵人任務方向)", "X", "Y"),
new Array(255, "走路花妖", 4, 8, 39, 25, 12, 19, "D", 3, "N", 3, 9, "布拉基姆高地", "布拉基姆高地(165.243)(蟲洞側)", "?", "Y"),
new Array(256, "跑步花妖", 4, 14, 41, 16, 17, 14, "A", 8, "N", 3, 8, "黑歷史之石洞20~27", "黑歷史之石洞6F(240.130)([岩屋七賢]任務,由5F(219.90)往下到6F)", "X", "Y"),
new Array(257, "舞蹈花妖", 4, 45, 14, 11, 7, 38, "B", 7, "N", 3, 7, "蟲洞28~31", "辛梅爾(181.82)公寓[騎寵駕訓班]任務第9天與溜五郎教官對話取得", "X", "Y"),
new Array(258, "(未命名)(缺)", 4, 13, 38, 23, 8, 8, "A", 3, "S", 3, "?", "X", "X", "X", "Y"),
new Array(261, "拉札魟怪", 2, 26, 31, 20, 24, 9, "C", 7, "N", 2, 8, "光之路", "光之路(218.103)(221.103)", "X", "Y"),
new Array(262, "拉賈魟怪", 2, 35, 24, 13, 31, 7, "D", 10, "X", "?", 8, "雪拉威森塔", "雪拉威森塔第30層(41.57)", "X", "Y"),
new Array(263, "烏賊怪;", 4, 29, 33, 38, 7, 8, "C", 6, "N", 4, 7, "光之路", "光之路(264.250)", "X", "Y"),
new Array(272, "羅查", 7, 11, 20, 25, 35, 19, "B", 10, "N", 2, 8, "雪拉威森塔", "雪拉威森塔28F(68.63)", "X", "Y"),
new Array(282, "潛地龍", 6, 33, 38, 33, 4, 8, "D", 8, "N", 1, 7, "光之路", "光之路(190.92)(196.89)", "X", "Y"),
new Array(283, "布卡", 0, 27, 22, 13, 45, 8, "A", 9, "S", 2, 8, "光之路、雪拉威森塔5-14F", "雪拉威森塔14F全域(以二連戰方式登場)", "X", "Y"),
new Array(286, "妖化布卡", 0, 18, 15, 16, 51, 15, "C", 1, "S", 2, 8, "光之路、雪拉威森塔", "雪拉威森塔33F全域(以二連戰方式登場)", "X", "Y"),
new Array(291, "玫瑰粉怪", 5, 7, 23, 46, 28, 6, "A", 10, "N", 2, 8, "雪拉威森塔", "雪拉威森塔34F(52.186)", "X", "Y"),
new Array(300, "德魯伊之鬼", 5, 16, 12, 23, 22, 47, "A", 10, "N", 2, 8, "雪拉威森塔", "雪拉威森塔", "X", "Y"),
new Array(303, "尤拉蝙蝠", 2, 22, 22, 22, 22, 22, "A", 10, "N", 1, 10, "試驗之間第三區域", "試驗之間第三區域,新手任務完成後隨機二選一", "X", "Y"),
new Array(304, "歐比爾蝙蝠", 2, 22, 22, 22, 22, 22, "B", 10, "N", 1, 10, "光之路", "X", "X", "Y"),
new Array(305, "韋伯蝙蝠", 2, 22, 22, 22, 22, 22, "C", 10, "N", 1, 10, "雪拉威森塔", "雪拉威森塔5F(273.172)", "X", "Y"),
new Array(306, "歐圖蝙蝠", 2, 22, 22, 22, 22, 22, "D", 10, "N", 1, 10, "試驗之間第二區域", "試驗之間第二區域,新手任務完成後隨機二選一", "X", "Y"),
new Array(307, "愛絲波波", 5, 34, 35, 18, 19, 14, "D", 5, "N", 1, 10, "未開放", "當期回饋卷", "X", "Y")
)

//定義未練寵檔次計算機需要的參數
calculated = false
failure = false
ptList = new Array()
classCalcOpen = true
oType = 1
ptType = -1
BPNameList = new Array('體', '力', '強', '速', '魔')
BPNL = new Array('體力', '力量', '強度', '速度', '魔法')
attNL = new Array('地', '水', '火', '風')
numNL = new Array('零', '一', '二', '三', '四', '五', '六', '七', '八', '九', '十')
attCol = new Array('00FF00', '00FFFF', 'FF0000', 'FFFF00')
statNameList = new Array('血', '魔', '攻', '防', '敏', '精', '回')
raceNames = new Array('野獸系', '不死系', '飛行系', '昆蟲系', '植物系', '特殊系', '金屬系', '龍型系', '人型系', '邪魔系')

picDir = "/pet/petIMG/"
level = 1
base = 0.2
inputBackup = ''
ts = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) //暫存用
tv = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) //暫存用
te = 7 //隨機te檔, 用來計算能力範圍
incompleteText = '(缺)'
toLvTimerStop = false
toLvTimerDir = "up"
toLvTimer = 0
bpAllocState = new Array("純加", "混加", "自訂")
defaultToLv = 90
simVar = new Array()
simBpDrop = new Array(0, 0, 0, 0, 0)
simRanBp = new Array(2, 2, 2, 2, 2)
simGrowth = 5
simPt = new Array(0, 0, 0, 0, 0)
ranBpSum = 10
initialBp = new Array(0, 0, 0, 0, 0)
growthBp = new Array(0, 0, 0, 0, 0)
allocBp = new Array(0, 0, 0, 0, 0, 0)
finalBp = new Array(0, 0, 0, 0, 0)
simOutputPrecision = 0
simOutputText = ""
simOutputText2 = ""
realInitial = new Array(12)
realFinal = new Array(12)
simCompareSourceI = new Array(12)
simCompareSourceF = new Array(12)
simCompare = false
ranCompare = new Array(24)
ranDiffVal = new Array(24)
bestRanDiff = 0
bestRanSet = new Array(5)

//顏色列表:        0背景     1掉檔     2隨機檔   3成長係數 4主配點   5副配點
colors = new Array("#E8FAFF", "#99FFCC", "#CCFF99", "#CCCCFF", "#99CCFF", "#99EEFF")

//定義寵物成長模擬需要的參數
toLv = 130
//simBP存放寵物在各級時的BP, 順序是0體1力2強3速4魔順序, 例: simBP[70][2] = 55.5 代表說70級的強BP是55.5
simBP = new Array()

//allocBP[0]存放寵物在該級的配點, 代碼是0體1力2強3速4魔5未配, allocBP[1]存放未分配的點數
//例: 如allocBP[70][0] = 1, 代表升70級時點力. allocBP[70][1] = 12, 代表70級時尚有12點未分配
//allocBP = new Array()

function loadMenu(menuIndex) {
    with (document.choose.ptMenu) {
        var itemNum = 0
        document.choose.ptMenu.options.length = 0;
        if (menuIndex == -1) {
            for (var ptNum in Pts) options[ptNum] = new Option(Pts[ptNum][1], Pts[ptNum][0])
        } else {
            for (var ptNum in Pts) {
                if (Pts[ptNum][2] == menuIndex) {
                    options[itemNum] = new Option(Pts[ptNum][1], Pts[ptNum][0])
                    itemNum++
                }
            }
        }
        if (choose.ptMenu.options[0]) {
            choose.ptMenu.options[0].selected = true;
        }
        loadData()
    }
}

function findPtType(menuItemIndex) {
    menuItemIndex = parseInt(menuItemIndex)
    if (Pts[menuItemIndex] && (Pts[menuItemIndex][0] == menuItemIndex)) return menuItemIndex
    else for (var ptNum in Pts) if (Pts[ptNum][0] == menuItemIndex) return ptNum
}

function printStarText(num) {
    var line = "<TD><B>" + BPNL[num] + ":</B></TD><TD>"
    if (Pts[ptType][3 + num] < 10) line += "&nbsp;"
    line += Pts[ptType][3 + num] + "&nbsp;" + padc("left", 10, printStar(Pts[ptType][3 + num])) + "</TD>"
    return line
}

function printAttText(num) {
    var block = "■"
    var line = "<TD><B>" + attNL[num] + ":</B></TD><TD>"
    var att = Pts[ptType][8].charCodeAt(0) - 65
    var amount = Pts[ptType][9]
    if (att == num) amount = amount
    else if ((att + 1) == num || (att - 3) == num) amount = 10 - amount
    else if (att == 23) {
        if (num == 0) amount = Math.floor(amount / 1000)
        else if (num == 1) amount = Math.floor((amount - Math.floor(amount / 1000) * 1000) / 100)
        else if (num == 2) amount = (amount % 100 - amount % 10) / 10
        else if (num == 3) amount = amount % 10
    } else amount = 0
    line += pad("right", 2, amount) + "&nbsp; <FONT color=#" + attCol[num] + ">"
    for (var i = amount; i--; i < amount) line += block
    amount = 20 - amount * 2
    for (var i = amount; i--; i < amount) line += "&nbsp;"
    line += "</FONT></TD></TR>"
    return line
}

function loadData() {
    sets = new Array()
    now = new Date()
    if (choose.ptMenu.value < 0) {
        inputBackup = choose.input.value
        return
    }
    ptType = findPtType(choose.ptMenu.value)
    oType = choose.outputType.value
    level = parseInt(choose.ptLevel.value)
    var dataText
    //dataText = "<TABLE border=1 bordercolor='#00CCFF' style='border: solid table-layout: fixed'><TR><TD><B>圖鑑編號:</B></TD><TD>" + Pts[ptType][0] + "</TD>"
    dataText = "<TABLE border=0 bordercolor='#00CCFF' table-layout: fixed'><TR><TD><B>圖鑑編號:</B></TD><TD>" + Pts[ptType][0] + "</TD>"
    dataText += printStarText(0)
    dataText += "<TD><B>圖鑑:</B></TD><TD>"
    if (Pts[ptType][11] == "X") dataText += "無"
    else {
        if (Pts[ptType][11] == "?") dataText += "&nbsp;?級"
        else dataText += numNL[Pts[ptType][11]] + "級"
        if (Pts[ptType][10] == "N") dataText += "普"
        else if (Pts[ptType][10] == "S") dataText += "銀"
        else if (Pts[ptType][10] == "G") dataText += "金"
        else dataText += "&nbsp;?"
        dataText += "卡"
        if (Pts[ptType][16] == "N") dataText += ", 不可封印"
    }
    dataText += "</TD>"

    //注意: 布卡改造前後圖片不一樣
    var picNum = Pts[ptType][0]
    if (choose.showPic.checked) {
        if (picNum > 1000 && picNum < 9000) picNum %= 1000
        if (picNum <= 310) {
            dataText += "<TD rowspan=7 align=center><IMG src='" + picDir
            for (var i = 0; i < (3 - (picNum + "").length); i++) dataText += "0"
            dataText += picNum + ".gif'></TD>"
        }
    }
    dataText += "<TR><TD><B>寵物名:</B></TD><TD>" + padc("left", 16, Pts[ptType][1])
    dataText += printStarText(1)
    dataText += printAttText(0)
    dataText += "<TR><TD><B>種族:</B></TD><TD>" + raceNames[Pts[ptType][2]]
    dataText += printStarText(2)
    dataText += printAttText(1)
    dataText += "<TR><TD><B>技能欄:</B></TD><TD>" + Pts[ptType][12]
    dataText += printStarText(3)
    dataText += printAttText(2)
    var totalClass = 0
    for (var i = 3; i < 8; i++) totalClass += Pts[ptType][i]
    dataText += "<TR><TD><B>總成長:</B></TD><TD>"
    dataText += totalClass
    dataText += printStarText(4)
    dataText += printAttText(3)
    //dataText += "<TR><TD><B>出沒地點</B></TD><TD colspan=6>&nbsp;</TD></TR>"
    dataText += "<TR><TD><B>出沒地點:</B></TD><TD colspan=5 width=600>"
    if (Pts[ptType][13] == "X") dataText += "(未開放/不明)"
    else dataText += Pts[ptType][13]
    dataText += "</TD></TR>"
    dataText += "<TR><TD><B>一級點:</B></TD><TD colspan=3 width=400>"
    if (Pts[ptType][14] == "X") dataText += "(未開放/不明)"
    else dataText += Pts[ptType][14]
    dataText += "</TD><TD><B>出現率:</B></TD><TD>"
    if (Pts[ptType][15] == "?") dataText += "(極低/缺乏資料)"
    else if (Pts[ptType][15] == "X") {
        if (Pts[ptType][11] == "X") dataText += "(無圖鑑, 不可封印)"
        else dataText += "(缺乏資料)"
    } else dataText += Pts[ptType][15] + "分鐘"
    dataText += "</TD></TR>"
    dataText += "</TABLE>"
    printTo('data_area', dataText)

    $("#classCalc").show();

}

//由圖鑑編號判斷一級每檔BP
function calBaseBP(num) {
    //#37使魔, #46小蝙蝠, #9001~#9004牛鬼
    if (num == 37 || num == 46 || num == 9001 || num == 9002 || num == 9003 || num == 9004) return 0.3
    //#221小鴨子, 非一級時, 每檔BP=0.22
    else if (num == 221 || num == 46 && level > 1) return 0.22
    //#2307二改愛絲波波
    else if (num == 2307 || num == 239) return 0.25
    //其他所有寵
    return 0.2
}

function preCalSetup() {
    ptType = undefined
    loadData()
    if (ptType == undefined) {
        helpMessage()
        return true
    }
    index = Pts[ptType][0]
    name = Pts[ptType][1]
    race = Pts[ptType][2]
    base = calBaseBP(index)
    return false
}

function calculate() {
    if (preCalSetup()) return
    parseLines(choose.input.value)
    li = 0
    for (li in sets) parseLine(sets[li])
    if (sets.length == 0 || failure) {
        calculated = true
        failure = true
        helpMessage()
        return
    }
    if (choose.clearOutput.checked) o = ''
    output()
    calculated = true
    return
}

function parseLines(lines) {
    var tempSets = lines.split(/\n/)
    var j = 0
    for (var i in tempSets) {
        tempSets[i] = tempSets[i].split(/[^0-9#]/)
        var nums = new Array()
        var m = 0
        for (var k in tempSets[i]) {
            tempSets[i][k] = parseInt(tempSets[i][k])
            if (!isNaN(tempSets[i][k])) {
                nums[m] = tempSets[i][k]
                m++
            }
        }
        tempSets[i] = nums
        if (tempSets[i].length >= 6) {
            sets[j] = tempSets[i]
            j++
        }
    }
}

function parseLine(line) {
    console.log(line)
    numOfResults = 0
    BPClSum = 0
    BPCl = new Array()
    BPMax = new Array(5)
    BPMin = new Array(5)
    cfLoss = new Array(0, 0, 0, 0, 0)
    maxLoss = new Array()
    totalLoss = 0
    lossMin = 20
    lossMax = 0
    cfLossSummary = new Array(4, 4, 4, 4, 4)
    maxLossSummary = new Array(0, 0, 0, 0, 0)
    for (var b = 0; b < 5; b++) {
        BPCl[b] = Pts[ptType][b + 3]
        BPClSum = BPClSum + BPCl[b]
    }
    //shift entire array if it appears first number represents level
    //this works up to lv 19
    // debugger;//   1 122 102 36 33 28

    if (line.length > 5) {
        level = line[0];
        line.shift()
    }
    ptList[li] = new pt(line)
    var p = ptList[li]

//目前野寵會有部份無解, 因為檔次論的野寵公式跟實際野寵能力有誤差
//errorMargin這個參數是為了設定可容許的誤差值, 但程式目前計算野寵有bug, 所以暫設為0
    var errorMargin = 0
    var loop = 6
    if (level == 1) {
        loop = 1
        errorMargin = 0
    }
    for (var gr = 0; gr < loop; gr++) {
        for (var b = 0; b < 5; b++) {
            BPMax[b] = Pts[ptType][b + 3] + 10
            BPMin[b] = Pts[ptType][b + 3] - 4
        }
        baseBP = (base * 1000 + (40 + gr) * (level - 1)) / 1000
        //add('baseBP = ' + baseBP + '<BR>')
        if (p.BP) {
            //formula is: (base+(40+gr)/1000*(level-1)), gr=0,1,2,3,4,5
            for (var b in BPMax) {
                BPMax[b] = Math.min(BPMax[b], Math.floor((p.BP[b] + 1 + errorMargin) / baseBP))
                BPMin[b] = Math.max(BPMin[b], Math.ceil((p.BP[b] - errorMargin) / baseBP))
            }
        }
        BPMax[0] = Math.min(BPMax[0], Math.floor((p.stat[0] + 1 + errorMargin) / 8 / baseBP))
        BPMax[1] = Math.min(BPMax[1], Math.floor((p.stat[2] + 1 + errorMargin) / 2.7 / baseBP))
        BPMax[2] = Math.min(BPMax[2], Math.floor((p.stat[3] + 1 + errorMargin) / 3 / baseBP))
        BPMax[3] = Math.min(BPMax[3], Math.floor((p.stat[4] + 1 + errorMargin) / 2 / baseBP))
        BPMax[4] = Math.min(BPMax[4], Math.floor((p.stat[1] + 1 + errorMargin) / 10 / baseBP))
        //add('Early BPMax = ' + BPMax + '<BR>')
        //add('Early BPMin = ' + BPMin + '<BR>')
        var breaker = 0
        while (true) {
            breaker++
            var total = 0
            for (var q in BPMax) total = total + BPMax[q] - BPMin[q]
            BPMin[0] = Math.min(BPMax[0], Math.max(BPMin[0], Math.ceil((p.stat[0] - errorMargin - (BPMax[1] * 2 + BPMax[2] * 3 + BPMax[3] * 3 + BPMax[4] * 1) * baseBP) / 8 / baseBP)))
            BPMin[1] = Math.min(BPMax[1], Math.max(BPMin[1], Math.ceil((p.stat[2] - errorMargin - (BPMax[0] * 2 + BPMax[2] * 3 + BPMax[3] * 3 + BPMax[4] * 2) / 10 * baseBP) / 2.7 / baseBP)))
            BPMin[2] = Math.min(BPMax[2], Math.max(BPMin[2], Math.ceil((p.stat[3] - errorMargin - (BPMax[0] * 2 + BPMax[1] * 3 + BPMax[3] * 3 + BPMax[4] * 2) / 10 * baseBP) / 3 / baseBP)))
            BPMin[3] = Math.min(BPMax[3], Math.max(BPMin[3], Math.ceil((p.stat[4] - errorMargin - (BPMax[0] * 1 + BPMax[1] * 2 + BPMax[2] * 2 + BPMax[4] * 1) / 10 * baseBP) / 2 / baseBP)))
            BPMin[4] = Math.min(BPMax[4], Math.max(BPMin[4], Math.ceil((p.stat[1] - errorMargin - (BPMax[0] * 1 + BPMax[1] * 2 + BPMax[2] * 2 + BPMax[3] * 2) * baseBP) / 10 / baseBP)))
            BPMax[0] = Math.max(BPMin[0], Math.min(BPMax[0], Math.floor(((p.stat[0] + 1 + errorMargin) - (BPMin[1] * 2 + BPMin[2] * 3 + BPMin[3] * 3 + BPMin[4] * 1) * baseBP) / 8 / baseBP)))
            BPMax[1] = Math.max(BPMin[1], Math.min(BPMax[1], Math.floor(((p.stat[2] + 1 + errorMargin) - (BPMin[0] * 2 + BPMin[2] * 3 + BPMin[3] * 3 + BPMin[4] * 2) / 10 * baseBP) / 2.7 / baseBP)))
            BPMax[2] = Math.max(BPMin[2], Math.min(BPMax[2], Math.floor(((p.stat[3] + 1 + errorMargin) - (BPMin[0] * 2 + BPMin[1] * 3 + BPMin[3] * 3 + BPMin[4] * 2) / 10 * baseBP) / 3 / baseBP)))
            BPMax[3] = Math.max(BPMin[3], Math.min(BPMax[3], Math.floor(((p.stat[4] + 1 + errorMargin) - (BPMin[0] * 1 + BPMin[1] * 2 + BPMin[2] * 2 + BPMin[4] * 1) / 10 * baseBP) / 2 / baseBP)))
            BPMax[4] = Math.max(BPMin[4], Math.min(BPMax[4], Math.floor(((p.stat[1] + 1 + errorMargin) - (BPMin[0] * 1 + BPMin[1] * 2 + BPMin[2] * 2 + BPMin[3] * 2) * baseBP) / 10 / baseBP)))
            for (var q in BPMax) total = total - BPMax[q] + BPMin[q]
            if (total > 70 || total == 0 || breaker > 20) break;
        }
        //add('Gr    = ' + gr    + ' | ')
        //add('BPMax = ' + BPMax + ' | ')
        //add('BPMin = ' + BPMin + '<BR>')
        for (var a = BPMin[0]; a <= BPMax[0]; a++) {
            for (var b = BPMin[1]; b <= BPMax[1]; b++) {
                for (var c = BPMin[2]; c <= BPMax[2]; c++) {
                    for (var d = BPMin[3]; d <= BPMax[3]; d++) {
                        for (var e = BPMin[4]; e <= BPMax[4]; e++) {
                            var cor = true
                            var combo = new Array(a, b, c, d, e)
                            for (var co in p.stat) {
                                var thisStat = Math.floor(stat(co, a, b, c, d, e) * baseBP)
                                if (level == 1) cor = cor && thisStat == p.stat[co]
                                else cor = cor && (Math.abs(thisStat - p.stat[co]) <= errorMargin)
                                //add((Math.floor(stat(co,a,b,c,d,e)*baseBP) + 'vs' + p.stat[co]) + ' | ')
                            }
                            var sum = a + b + c + d + e
                            cor = cor && ((BPClSum + 10) >= sum)
                            cor = cor && ((BPClSum - 10) <= sum)
                            if (cor && doCheckBP) {
                                for (var x = 0; x < 5; x++) {
                                    eval("cor = cor && (Math.floor(baseBP*" + String.fromCharCode(97 + x) + ")==p.BP[x])")
                                }
                                //add("BP check: " + baseBP*a + ' vs ' + p.BP[0] + "<BR>")
                                //add("BP check: " + baseBP*b + ' vs ' + p.BP[0] + "<BR>")
                                //add("BP check: " + baseBP*c + ' vs ' + p.BP[0] + "<BR>")
                                //add("BP check: " + baseBP*d + ' vs ' + p.BP[0] + "<BR>")
                                //add("BP check: " + baseBP*e + ' vs ' + p.BP[0] + "<BR>")
                            }
                            if (cor) {
                                var sureLoss = Math.max(0, BPCl[0] - a) + Math.max(0, BPCl[1] - b) +
                                    Math.max(0, BPCl[2] - c) + Math.max(0, BPCl[3] - d) + Math.max(0, BPCl[4] - e)
                                totalLoss = BPClSum + 10 - sum
                                if (sureLoss > totalLoss) cor = false
                            }
                            if (cor && p.spi != undefined) {
                                var thisSpi = Math.floor(spi(combo) * baseBP + 100)
                                if (level == 1) cor = cor && (p.spi == thisSpi)
                                else cor = cor && (Math.abs(thisSpi - p.spi) <= errorMargin)
                                //add('p.spi = ' + p.spi + ' vs ' + 'cal = ' + Math.floor(spi(combo)*baseBP+100))
                            }
                            if (cor && p.rev != undefined) {
                                var thisRev = Math.floor(rev(combo) * baseBP + 100)
                                if (level == 1) cor = cor && (p.rev == thisRev)
                                else cor = cor && (Math.abs(thisRev - p.rev) <= errorMargin)
                                //add('p.rev = ' + p.rev + ' vs ' + 'cal = ' + Math.floor(rev(combo)*baseBP+100))
                            }
                            if (cor) {
                                var solution = new Array(a, b, c, d, e)
                                p.sols[numOfResults] = new sol(solution, gr)
                                numOfResults++
                            }
                        }
                    }
                }
            }
        }
    }
//END OF INDEX USE

    if (numOfResults > 0) {
        p.lossMin = 20
        p.lossMax = 0
        p.cfLossSummary = new Array(4, 4, 4, 4, 4)
        p.maxLossSummary = new Array(0, 0, 0, 0, 0)
        if (p.spi == undefined) p.spi = Math.floor(p.sols[0].spi)
        if (p.rev == undefined) p.rev = Math.floor(p.sols[0].rev)
        if (p.BP == undefined) {
            p.BP = new Array(5)
            for (var st = 0; st < 5; st++) p.BP[st] = Math.floor(p.sols[0].BP[st])
        }
    }
    for (var r = 0; r < numOfResults; r++) {
        if (p.spi == undefined || (Math.floor(p.sols[r].spi) != p.spi)) p.spi = undefined
        if (p.rev == undefined || (Math.floor(p.sols[r].rev) != p.rev)) p.rev = undefined
        if (!doCheckBP) {
            //possible performance improvement here?
            for (var st = 0; st < 5; st++) {
                if (p.BP[st] == undefined) break
                else if (p.BP[st] != Math.floor(p.sols[r].BP[st])) p.BP[st] = undefined
            }
        }
        totalLoss = BPClSum + 10
        for (var st = 0; st < 5; st++) {
            p.sols[r].cfLoss[st] = Math.max(0, BPCl[st] - p.sols[r].cl[st])
            totalLoss -= p.sols[r].cl[st]
        }
        var minLoss = Math.max(0, totalLoss - 16)
        for (var st = 0; st < 5; st++) {
            p.sols[r].cfLoss[st] = Math.max(p.sols[r].cfLoss[st], minLoss)
            p.cfLossSummary[st] = Math.min(p.sols[r].cfLoss[st], p.cfLossSummary[st])
        }
        p.sols[r].loss = totalLoss
        p.lossMin = Math.min(p.lossMin, totalLoss)
        p.lossMax = Math.max(p.lossMax, totalLoss)
        var unCfLoss = totalLoss
        for (var st = 0; st < 5; st++) unCfLoss -= p.sols[r].cfLoss[st]
        for (var st = 0; st < 5; st++) {
            p.sols[r].maxLoss[st] = Math.min(unCfLoss + p.sols[r].cfLoss[st], 4)
            p.maxLossSummary[st] = Math.max(p.sols[r].maxLoss[st], p.maxLossSummary[st])
        }
    }
    for (var st = 0; st < 5; st++) p.stat[st] += 20
}

function output() {
    if (ptList.length == 1) add('<B>' + name + '能力分析:</B><BR><FONT FACE="細明體,Courier,System,MS Sans Serif">')
    else add('<br><br><B>' + ptList.length + '隻' + name + '能力分布:</B><BR><FONT FACE="細明體,Courier,System,MS Sans Serif">')
    var maxStat = new Array(5)
    var minStat = new Array(5)
    //note: undefined values are ignored, and possible utilisation of sol data
    //      to determine max/min is NOT implmented
    var maxBP = new Array(5)
    var minBP = new Array(5)
    var maxSpi, maxRev, minSpi, minRev, maxLoss, minLoss
    var minCfLoss = new Array(5)
    var minMaxLoss = new Array(5)
    var maxCfLoss = new Array(5)
    var maxMaxLoss = new Array(5)
    var lossLeftLen = 2, lossRightLen = 2
    //TO DO: add Switch later for printSR
    var printSR = true

    //finding max and min values
    for (var st = 0; st < 5; st++) {
        maxStat[st] = ptList[0].stat[st]
        minStat[st] = ptList[0].stat[st]
        if (ptList[0].sols != undefined && ptList[0].sols.length > 0) {
            if (ptList[0].BP[st]) {
                maxBP[st] = ptList[0].BP[st]
                minBP[st] = ptList[0].BP[st]
            }
        }
    }
    for (var p in ptList) {
        for (var st = 0; st < 5; st++) {
            maxStat[st] = Math.max(maxStat[st], ptList[p].stat[st])
            minStat[st] = Math.min(minStat[st], ptList[p].stat[st])
            if (ptList[p].BP != undefined && ptList[p].BP[st]) {
                if (maxBP[st] == undefined) {
                    maxBP[st] = ptList[p].BP[st]
                    minBP[st] = ptList[p].BP[st]
                } else {
                    maxBP[st] = Math.max(maxBP[st], ptList[p].BP[st])
                    minBP[st] = Math.min(minBP[st], ptList[p].BP[st])
                }
            }
        }
        if (ptList[p].sols.length > 0) {
            if (maxLoss == undefined) {
                maxLoss = ptList[p].lossMin * 100 + ptList[p].lossMax
                minLoss = ptList[p].lossMin * 100 + ptList[p].lossMax
                for (var st = 0; st < 5; st++) {
                    minCfLoss[st] = ptList[p].cfLossSummary[st]
                    maxCfLoss[st] = ptList[p].cfLossSummary[st]
                    minMaxLoss[st] = ptList[p].maxLossSummary[st]
                    maxMaxLoss[st] = ptList[p].maxLossSummary[st]
                }
            } else {
                var thisLoss = ptList[p].lossMin * 100 + ptList[p].lossMax
                if (thisLoss > maxLoss) {
                    maxLoss = thisLoss
                    for (var st = 0; st < 5; st++) {
                        maxCfLoss[st] = ptList[p].cfLossSummary[st]
                        maxMaxLoss[st] = ptList[p].maxLossSummary[st]
                    }
                }
                if (thisLoss < minLoss) {
                    minLoss = thisLoss
                    for (var st = 0; st < 5; st++) {
                        minCfLoss[st] = ptList[p].cfLossSummary[st]
                        minMaxLoss[st] = ptList[p].maxLossSummary[st]
                    }
                }
            }
            if (lossRightLen == 2 && ptList[p].lossMax > 9 && (ptList[p].lossMax != ptList[p].lossMin)) lossRightLen = 3
        }
        if (printSR) {
            if (ptList[p].spi != undefined) {
                if (maxSpi == undefined) {
                    maxSpi = ptList[p].spi
                    minSpi = ptList[p].spi
                } else {
                    maxSpi = Math.max(maxSpi, ptList[p].spi)
                    minSpi = Math.min(minSpi, ptList[p].spi)
                }
            }
            if (ptList[p].rev != undefined) {
                if (maxRev == undefined) {
                    maxRev = ptList[p].rev
                    minRev = ptList[p].rev
                } else {
                    maxRev = Math.max(maxRev, ptList[p].rev)
                    minRev = Math.min(minRev, ptList[p].rev)
                }
            }
        }
    }
    if (maxLoss >= 1000) lossLeftLen = 3
    var solLossPad = Math.max(lossLeftLen, lossRightLen)
    var checkUndefined = new Array('maxSpi', 'maxRev', 'minSpi', 'minRev', 'maxLoss', 'minLoss')
    for (var st in checkUndefined) if (!eval(checkUndefined[st])) eval(checkUndefined[st] + "='?'")
    for (var st = 0; st < 5; st++) {
        if (!maxBP[st]) maxBP[st] = '?'
        if (!minBP[st]) minBP[st] = '?'
    }
//actual printing bit start here:
    var ptL = Math.max((((ptList.length + 1) + "").length + 2), 4)
    var lineOutput = ""
    if (oType != 1 && ptList.length != 1) lineOutput += padc("right", 4, "編號")
    for (var i = 0; i < 5; i++) {
        lineOutput += padc("right", (maxStat[i] + "").length, statNameList[i]) + '&nbsp;'
        if (oType == 1) lineOutput += '&nbsp;&nbsp;&nbsp;'
    }
    lineOutput += padc("right", (maxSpi + "").length, statNameList[5]) + '&nbsp;'
    if (oType == 1) lineOutput += '&nbsp;&nbsp;&nbsp;'
    lineOutput += padc("right", (maxRev + "").length, statNameList[6]) + '&nbsp;'
    if (oType == 1) lineOutput += '&nbsp;&nbsp;&nbsp;'
    for (var i = 0; i < 5; i++) {
        if (i != 0 && (maxBP[0] + "").length > 1 && (maxBP[i] + "").length > 1) lineOutput += '&nbsp;'
        lineOutput += padc("right", (maxBP[i] + "").length, BPNameList[i])
        if (oType == 1) lineOutput += '&nbsp;&nbsp;'
    }
    if (!isNaN(maxLoss)) {
        lineOutput += padc("right", lossLeftLen, "檔")
        if (oType != 1) {
            lineOutput += pad("right", lossRightLen + 3, "") + '&nbsp;'
            lineOutput += "至少掉&nbsp;&nbsp;&nbsp;&nbsp;最多掉"
        } else lineOutput += "&nbsp;至少掉最多掉"
    }
    lineOutput += "<BR>"
    for (var p in ptList) {
        p = parseInt(p)
        if (ptList.length != 1) {
            lineOutput += pad("right", ptL, ("#" + (p + 1) + ":"))
            if (oType == 1) lineOutput += "<BR>"
        }
        for (var st = 0; st < 5; st++) {
            lineOutput += pad("right", (maxStat[st] + "").length, ptList[p].stat[st]) + '&nbsp;'
            if (oType == 1) lineOutput += '&nbsp;&nbsp;&nbsp;'
        }
        if (printSR) {
            lineOutput += pad("right", (maxSpi + "").length, ptList[p].spi) + '&nbsp;'
            if (oType == 1) lineOutput += '&nbsp;&nbsp;&nbsp;'
            lineOutput += pad("right", (maxRev + "").length, ptList[p].rev) + '&nbsp;'
            if (oType == 1) lineOutput += '&nbsp;&nbsp;&nbsp;'
        }
        for (var st = 0; st < 5; st++) {
            if (ptList[p].BP == undefined) lineOutput += pad("right", (maxBP[st] + "").length, undefined) + '&nbsp;'
            else lineOutput += pad("right", (maxBP[st] + "").length, ptList[p].BP[st]) + '&nbsp;'
            if (oType == 1) lineOutput += '&nbsp;&nbsp;'
        }
        if (ptList[p].cfLossSummary == undefined) {
            lineOutput += "無解<BR>"
        } else {
            if (oType != 1) lineOutput += pad("right", lossLeftLen, "-" + ptList[p].lossMin)
            if (ptList[p].lossMin != ptList[p].lossMax) {
                if (oType == 1) lineOutput += pad("right", lossLeftLen, "-?") + '&nbsp;'
                else lineOutput += " ~ " + pad("right", lossRightLen, "-" + ptList[p].lossMax) + '&nbsp;'
            } else if (oType == 1) lineOutput += pad("right", lossLeftLen, "-" + ptList[p].lossMin) + '&nbsp;'
            else lineOutput += pad("right", lossRightLen + 3, "") + '&nbsp;'
            if (oType == 1) {
                for (var st = 0; st < 5; st++) lineOutput += ptList[p].cfLossSummary[st]
                lineOutput += '&nbsp;'
                for (var st = 0; st < 5; st++) lineOutput += ptList[p].maxLossSummary[st]
                lineOutput += '<BR>'
            } else lineOutput += ptList[p].cfLossSummary + '&nbsp;' + ptList[p].maxLossSummary + '<BR>'
        }

        if (oType == 1 && ptList[p].sols.length > 0) {
            var solLine = ""
            for (var s in ptList[p].sols) {
                for (var st in ptList[p].sols[s].stat) {
                    solLine += pad("right", (maxStat[st] + "").length + 3, ptList[p].sols[s].stat[st].toFixed(2)) + '&nbsp;'
                }
                solLine += pad("right", (maxSpi + "").length + 3, ptList[p].sols[s].spi.toFixed(2)) + '&nbsp;' + pad("right", (maxRev + "").length + 3, ptList[p].sols[s].rev.toFixed(2)) + '&nbsp;'
                for (var b in ptList[p].sols[s].BP) {
                    solLine += pad("right", (maxBP[st] + "").length + 2, ptList[p].sols[s].BP[b].toFixed(1)) + '&nbsp;'
                }
                solLine += pad("right", solLossPad, '-' + ptList[p].sols[s].loss) + '&nbsp;'
                for (var st = 0; st < 5; st++) solLine += ptList[p].sols[s].cfLoss[st]
                solLine += '&nbsp;'
                for (var st = 0; st < 5; st++) solLine += ptList[p].sols[s].maxLoss[st]
                solLine += '<BR>'
            }
            solLine += '<BR>'
            lineOutput += solLine
        }
        if ((p % 2) == 0) {
            add(lineOutput)
            lineOutput = ""
        }
    }
    //need to account for 0 after % operation

    if (ptList.length > 1) {
        lineOutput += "<BR>"
        lineOutput += pad("right", ptL, "Max:")
        for (var st = 0; st < 5; st++) lineOutput += pad("right", (maxStat[st] + "").length, maxStat[st]) + '&nbsp;'
        if (printSR) lineOutput += pad("right", (maxSpi + "").length, maxSpi) + '&nbsp;' + pad("right", (maxRev + "").length, maxRev) + '&nbsp;'
        for (var st = 0; st < 5; st++) lineOutput += pad("right", (maxBP[st] + "").length, maxBP[st]) + '&nbsp;'
        if (isNaN(maxLoss)) lineOutput += "全部無解<BR>"
        else {
            if (isNaN(minLoss)) minLoss = 0
            lineOutput += pad("right", lossLeftLen, "-" + Math.floor(minLoss / 100))
            if (Math.floor(minLoss / 100) != (minLoss % 100)) lineOutput += ' ~ ' + pad("right", lossRightLen, "-" + (minLoss % 100)) + '&nbsp;'
            else lineOutput += pad("right", lossRightLen + 3, "") + '&nbsp;'
            lineOutput += minCfLoss + '&nbsp;' + minMaxLoss + '<BR>'
        }
        lineOutput += pad("right", ptL, "Min:")
        for (var st = 0; st < 5; st++) lineOutput += pad("right", (maxStat[st] + "").length, minStat[st]) + '&nbsp;'
        if (printSR) lineOutput += pad("right", (maxSpi + "").length, minSpi) + '&nbsp;' + pad("right", (maxRev + "").length, minRev) + '&nbsp;'
        for (var st = 0; st < 5; st++) lineOutput += pad("right", (maxBP[st] + "").length, minBP[st]) + '&nbsp;'
        if (isNaN(maxLoss)) lineOutput += "全部無解<BR>"
        else {
            lineOutput += pad("right", lossLeftLen, "-" + Math.floor(maxLoss / 100))
            if (Math.floor(maxLoss / 100) != (maxLoss % 100)) lineOutput += ' ~ ' + pad("right", lossRightLen, "-" + (maxLoss % 100)) + '&nbsp;'
            else lineOutput += pad("right", lossRightLen + 3, "") + '&nbsp;'
            lineOutput += maxCfLoss + '&nbsp;' + maxMaxLoss + '<BR>'
        }
    }

    ptList = new Array()
    end = new Date()
    if (name.substring(name.length - incompleteText.length) == incompleteText) {
        lineOutput += '<BR>檔次有缺, 以上計算結果僅供參考, 歡迎提供成長紀錄以補齊檔次.<BR>成長紀錄只需要練過後的能力值,配點方式,補抓時的等級還有現有等級即可, 不用每級紀錄.<BR>'
    }
    lineOutput += '</FONT><BR>本次計算共花費 ' + (end - now) / 1000 + ' 秒<BR>'
    lineOutput += '<HR NOSHADE COLOR="#400080">'
    add(lineOutput)
    printTo('myDiv3', o)
    printTo('helpText', "計算完畢，結果如下：")
}

function pad(pos, len, text) {
    if (text == undefined) text = '?'
    text = "" + text
    len = (len - text.length)
    if (pos == "right") {
        for (var pa = 0; pa < len; pa++) {
            text = "&nbsp;" + text
        }
        return text
    }
    if (pos == "center") {
        for (var pa = 0; pa < Math.floor(len / 2); pa++) {
            text = "&nbsp;" + text
        }
        for (var pa = 0; pa < Math.ceil(len / 2); pa++) {
            text = text + "&nbsp;"
        }
        return text
    }
    if (pos == "left") {
        for (var pa = 0; pa < len; pa++) {
            text = text + "&nbsp;"
        }
        return text
    }
}

function padc(pos, len, text) {
    if (text == undefined) text = '?'
    text = "" + text
    len = (len - text.length * 2)
    //處理半型括號被當成兩格的問題, 假設括號一定成對出現
    if (/[\(-\)]/g.test(text)) len += 2
    if (pos == "right") {
        for (var pa = 0; pa < len; pa++) {
            text = "&nbsp;" + text
        }
        return text
    }
    if (pos == "center") {
        for (var pa = 0; pa < Math.floor(len / 2); pa++) {
            text = "&nbsp;" + text
        }
        for (var pa = 0; pa < Math.ceil(len / 2); pa++) {
            text = text + "&nbsp;"
        }
        return text
    }
    if (pos == "left") {
        for (var pa = 0; pa < len; pa++) {
            text = text + "&nbsp;"
        }
        return text
    }
}

function rev(list) {
    return ((list[0] * 8 - list[1] - list[2] + list[3] * 2 - list[4] * 3) / 10)
}

function spi(list) {
    return ((-list[0] * 3 - list[1] + list[2] * 2 - list[3] * 1 + list[4] * 8) / 10)
}

function stat(type, a, b, c, d, e) {
    if (arguments.length == 2) {
        return stat(type, arguments[1][0], arguments[1][1], arguments[1][2], arguments[1][3], arguments[1][4])
    }
    var precision = 3
    a = a.toFixed(precision)
    b = b.toFixed(precision)
    c = c.toFixed(precision)
    d = d.toFixed(precision)
    e = e.toFixed(precision)
    type = parseInt(type)
    switch (type) {
        case 0 :
            return a * 8 + b * 2 + c * 3 + d * 3 + e * 1
        case 1 :
            return a * 1 + b * 2 + c * 2 + d * 2 + e * 10
        case 2 :
            return (a * 2 + b * 27 + c * 3 + d * 3 + e * 2) / 10
        case 3 :
            return (a * 2 + b * 3 + c * 30 + d * 3 + e * 2) / 10
        default:
            return (a * 1 + b * 2 + c * 2 + d * 20 + e * 1) / 10
    }
}

function getRefToDiv(divID) {
    if (document.layers) { //Netscape layers
        return document.layers[divID];
    }
    if (document.getElementById) { //DOM; IE5, NS6, Mozilla, Opera
        return document.getElementById(divID);
    }
    if (document.all) { //Proprietary DOM; IE4
        return document.all[divID];
    }
    return false;
}

function add(text) {
    o += text
}

function printTo(divID, text) {
    if (divID == 'helpText') text += '<HR NOSHADE COLOR="#400080">'
    myRef = getRefToDiv(divID)
    if (typeof (myRef.innerHTML) != 'undefined') {
        //used by the IE series, Konqueror, Opera 7+ and Gecko browsers
        myRef.innerHTML = text;
    } else {
        if (myRef.document && myRef.document != window.document) {
            //used by layers browsers
            myRef.document.open();
            myRef.document.write(text);
            myRef.document.close();
        } else {
            if (window.frames && window.frames.length && window.frames['nameOfIframe']) {
                //used by browsers like Opera 6-
                myRef = window.frames['nameOfIframe'].window;
                myRef.document.open();
                myRef.document.write(text);
                myRef.document.close();
            }
        }
    }
}

function showDiv(divID) {
    myRef = getRefToDiv(divID)
    if (!myRef) return
    if (myRef.style) myRef.style.visibility = 'visible'
    else if (myRef.visibility) myRef.visibility = 'show'
    return
}

function hideDiv(divID) {
    myRef = getRefToDiv(divID)
    if (!myRef) return
    if (myRef.style) myRef.style.visibility = 'hidden'
    else if (myRef.visibility) myRef.visibility = 'hide'
    return
}

function helpMessage() {
    if (isNaN(parseInt(choose.ptLevel.value))) {
        printTo('helpText', '等級欄請填數字.')
        return
    }
    if (failure) {
        printTo('helpText', '請檢查數據並依<b>血魔攻防敏 精回 體力強速魔</b>順序輸入寵物能力, 每行一隻寵, 然後按<b>開始計算</b>. 精神/回復/BP可以不填.')
        return
    }
    if (choose.ptMenu.value == "-1" || ptType == undefined) {
        printTo('helpText', '你還沒有選擇要算的寵物。')
    } else if (classCalcOpen && choose.input.value == '')
        printTo('helpText', '請依<b>血魔攻防敏 精回 體力強速魔</b>順序輸入寵物能力, 每行一隻寵, 然後按<b>開始計算</b>. 精神/回復/BP可以不填.')
    else if (calculated && !failure) printTo('helpText', '計算完畢，結果如下：')
    else if (!classCalcOpen && toLv < level) printTo('helpText', '初始等級需小於模擬等級, 目前初始等級為' + level + ', 模擬等級為' + toLv + '.')
    else if (!classCalcOpen && ranBpSum != 10) printTo('helpText', '隨機檔總合需為10, 目前總合為' + ranBpSum + '.')
    else if (!classCalcOpen && document.getElementById("userDefinedBp0").value < 0 && choose.bpAlloc.value == bpAllocState[2]) printTo('helpText', '配點已超過可分配點數, 請從自訂配點中扣除' + document.getElementById("userDefinedBp0").value * (-1) + '點. (可直接點選欲扣除的配點標題.)')
    else if (classCalcOpen) printTo('helpText', '準備就緒, 可以開始計算.')
    else printTo('helpText', '計算完畢.')
    return
}

function notDone() {
    calculated = false
    failure = false
}

function clearInput() {
    if (choose.input.value != '') inputBackup = choose.input.value
    choose.input.value = ''
}

function restoreInput() {
    if (inputBackup != '') choose.input.value = inputBackup
    notDone()
}

function copyDiv() {
    var old = choose.input.value
    choose.input.value = getRefToDiv("myDiv3").innerText
    var r = choose.input.createTextRange()
    r.select()
    r.execCommand('copy')
    choose.input.value = old
}

function printStar(num) {
    var star = "★"
    var hStar = "☆"
    var line = ""
    while (num >= 10) {
        line += star
        num -= 10
    }
    if (num >= 8) line += star
    else if (num >= 3) line += hStar
    return line
}

function toggleCalc() {
    if (classCalcOpen) {
        hideDiv('classCalc')
        showDiv('sim')
        classCalcOpen = false
        printTo('switch', '切換至一級寵物檔次計算機')
        printTo('heading', '寵物成長模擬')
        updateBpAllocSum()
    } else {
        hideDiv('sim')
        showDiv('classCalc')
        classCalcOpen = true
        printTo('switch', '切換至寵物成長模擬')
        printTo('heading', '一級寵物檔次計算機')
    }
    helpMessage()
}

//全寵物能力範圍表:
function createStatRangeTable() {
    level = parseInt(choose.ptLevel.value)
    var titleString = ""
    if (level == 1) titleString += "全寵物一"
    else titleString += "野生寵" + level
    titleString += "級能力範圍表"
    var srtText = "<HTML><TITLE>" + titleString + "</TITLE><BODY BGCOLOR=" + colors[0] + "><h1>" + titleString + "</h1><meta http-equiv=Content-Type content='text/html; charset=utf-8'>"
    //計算能力範圍
    var statRange = calStatRange()
    //排版
    srtText += "<TABLE BORDER=5 BGCOLOR='" + colors[0] + "' bordercolor='#00CCFF'><TBODY ALIGN='center'><TR><TD rowspan=2><B>編號</B></TD><TD rowspan=2><B>寵物名</B></TD>"
    srtText += "<TD colspan=12><B>單項能力範圍</B><small>(同隻寵不會同時有兩項五圍是頂的)</small></TD><TD></TD><TD colspan=12><B>滿檔/底檔寵能力參考</B><small>(隨機檔平均分布)</small></TD></TR>"
    for (var j = 0; j < 2; j++) {
        for (var i in statNameList) {
            srtText += "<TD><B>" + statNameList[i] + "</B></TD>"
        }
        for (var i in BPNameList) {
            srtText += "<TD><B>" + BPNameList[i] + "</B></TD>"
        }
        if (j == 0) srtText += "<TD></TD>"
    }
    srtText += "</TR></TBODY>"
    for (var i in statRange) {
        var srtTextTemp = ""
        srtTextTemp += "<TR><TBODY ALIGN='right'><TD rowspan=2>" + statRange[i][0] + "</TD>" + "<TD rowspan=2 align='center'>" + statRange[i][1] + "</TD>"
        for (var j = 2; j < 14; j++) {
            srtTextTemp += "<TD>" + statRange[i][j] + "</TD>"
        }
        srtTextTemp += "<TD></TD>"
        for (var j = 26; j < 38; j++) {
            srtTextTemp += "<TD>" + statRange[i][j] + "</TD>"
        }
        srtTextTemp += "</TR>"
        for (var j = 14; j < 26; j++) {
            srtTextTemp += "<TD>" + statRange[i][j] + "</TD>"
        }
        srtTextTemp += "<TD></TD>"
        for (var j = 38; j < 50; j++) {
            srtTextTemp += "<TD>" + statRange[i][j] + "</TD>"
        }
        srtTextTemp += "</TR>"
        srtText += srtTextTemp
    }
    srtText += "</TBODY></TABLE><BR>" +
        "<B>註1.</B> 全能力同時達到單項能力上限是不可能的.<BR>" +
        "<B>註2.</B> 達到部份上下限的機率約為 1/(5^12) ~= 兩億四千四百萬分之一<BR>" +
        "<B>註3.</B> 以上為野寵能力, 部分地區的怪或王經過大宇/ENIX手動調整, 所以能力將超出上列範圍.<BR>" +
        "<B>註4.</B> 寵名有標明 (缺) 的寵物無法正確計算能力範圍, 能力上下限都會低估.<BR>" +
        "<B>註5.</B> 滿檔寵能力參考是以隨機檔(2 2 2 2 2)配上頂成長係數(5)的方式計算, 野寵成長係數如果低於5, 滿檔能力會較列出的值低. 底檔寵如成長係數非0, 也會比列出值高.<BR>" +
        "<B>註6.</B> 以上計算限制隨機檔最多 " + te + "檔落在同一項能力.<BR>" +
        "</HTML>"
    return srtText
}

function printStat() {
    if (isNaN(parseInt(choose.ptLevel.value))) {
        helpMessage()
        return
    }
    OpenWindow = window.open("", "newwin", "")
    OpenWindow.document.write(createStatRangeTable())
    OpenWindow.document.close()
}

//能力範圍如以下方式計算(如te設為7, 超過此範圍的機率大都低於百萬分之一, 不予考慮, 以讓數據相對合理化):
//五圍上限 - 總成長滿檔+該寵隨機te檔配在能把該能力最大化的位置上, 其餘(10-te)檔配在第二好的位置.
//五圍下限 - 總成長底檔+該寵隨機te檔配在能把該能力最小化的位置上, 其餘(10-te)檔配在第二差的位置.
//精神上限 - 防魔滿檔, 體力速底檔, 該寵隨機te檔配在魔, (10-te)檔配在強.
//精神下限 - 防魔底檔, 體力速滿檔, 該寵隨機te檔配在體, (10-te)檔配在力.
//回復上限 - 體速滿檔, 力強魔底檔, 該寵隨機te檔配在體, (10-te)檔配在速.
//回復下限 - 體速底檔, 力強魔滿檔, 該寵隨機te檔配在魔, (10-te)檔配在力.
//BP上限 - 頂檔次*每檔BP + te*每檔BP
//BP下限 - 底檔次*每檔BP
//野寵以成長係數5用來計算能力上限, 成長係數0計算下限
function calStatRange() {
    var statRange = new Array(Pts.length)
    for (var i in Pts) {
        //計算各能力上限, 填到暫存變數ts中
        calStatMax(i)
        //計算各能力上限, 填到暫存變數tv中
        calStatMin(i)
        statRange[i] = new Array(Pts[i][0], Pts[i][1], 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
        for (var j = 0; j < 12; j++) {
            statRange[i][j + 2] = ts[j]
            statRange[i][j + 14] = tv[j]
            statRange[i][j + 26] = ts[j + 12]
            statRange[i][j + 38] = tv[j + 12]
        }
    }
    return statRange
}

function calStatMax(num) {
    var baseBP = (calBaseBP(Pts[num][0]) * 1000 + (40 + 5) * (level - 1)) / 1000
    for (var k = 0; k < 5; k++) {
        k = parseInt(k)
        switch (k) {
            case 0 :
                ts[0] = Math.floor(((Pts[num][3] + te) * 8 + Pts[num][4] * 2 + (Pts[num][5] + 10 - te) * 3 + Pts[num][6] * 3 + Pts[num][7] * 1) * baseBP + 20)
            case 1 :
                ts[1] = Math.floor((Pts[num][3] * 1 + Pts[num][4] * 2 + Pts[num][5] * 2 + (Pts[num][6] + 10 - te) * 2 + (Pts[num][7] + te) * 10) * baseBP + 20)
            case 2 :
                ts[2] = Math.floor(((Pts[num][3] * 2 + (Pts[num][4] + te) * 27 + (Pts[num][5] + 10 - te) * 3 + Pts[num][6] * 3 + Pts[num][7] * 2) / 10) * baseBP + 20)
            case 3 :
                ts[3] = Math.floor(((Pts[num][3] * 2 + (Pts[num][4] + 10 - te) * 3 + (Pts[num][5] + te) * 30 + Pts[num][6] * 3 + Pts[num][7] * 2) / 10) * baseBP + 20)
            default:
                ts[4] = Math.floor(((Pts[num][3] * 1 + (Pts[num][4] + 10 - te) * 2 + Pts[num][5] * 2 + (Pts[num][6] + te) * 20 + Pts[num][7] * 1) / 10) * baseBP + 20)
        }
    }
    ts[5] = Math.floor(((-(Pts[num][3] - 4) * 3 - (Pts[num][4] - 4) * 1 + (Pts[num][5] + 10 - te) * 2 - (Pts[num][6] - 4) * 1 + (Pts[num][7] + te) * 8) / 10) * baseBP + 100)
    ts[6] = Math.floor((((Pts[num][3] + te) * 8 - (Pts[num][4] - 4) - (Pts[num][5] - 4) + (Pts[num][6] + 10 - te) * 2 - (Pts[num][7] - 4) * 3) / 10) * baseBP + 100)
    for (var k = 7; k < 12; k++) ts[k] = Math.floor((Pts[num][3 + k - 7] + te) * baseBP)
    for (var k = 12; k < 17; k++) ts[k] = Math.floor(stat(k - 12, Pts[num][3] + 2, Pts[num][4] + 2, Pts[num][5] + 2, Pts[num][6] + 2, Pts[num][7] + 2) * baseBP + 20)
    ts[17] = Math.floor(((-(Pts[num][3] + 2) * 3 - (Pts[num][4] + 2) * 1 + (Pts[num][5] + 2) * 2 - (Pts[num][6] + 2) * 1 + (Pts[num][7] + 2) * 8) / 10) * baseBP + 100)
    ts[18] = Math.floor((((Pts[num][3] + 2) * 8 - (Pts[num][4] + 2) - (Pts[num][5] + 2) + (Pts[num][6] + 2) * 2 - (Pts[num][7] + 2) * 3) / 10) * baseBP + 100)
    for (var k = 19; k < 24; k++) ts[k] = Math.floor((Pts[num][3 + k - 19] + 2) * baseBP)
    return
}

function calStatMin(num) {
    var baseBP = (calBaseBP(Pts[num][0]) * 1000 + (40 + 0) * (level - 1)) / 1000
    var a = new Array(0, 0, 0, 0, 0)
    for (var i = 0; i < 5; i++) {
        a[i] = Pts[num][3 + i] - 4
    }
    for (var k = 0; k < 5; k++) {
        k = parseInt(k)
        switch (k) {
            case 0 :
                tv[0] = Math.floor((a[0] * 8 + (a[1] + 10 - te) * 2 + a[2] * 3 + a[3] * 3 + (a[4] + te) * 1) * baseBP + 20)
            case 1 :
                tv[1] = Math.floor(((a[0] + te) * 1 + (a[1] + 10 - te) * 2 + a[2] * 2 + a[3] * 2 + a[4] * 10) * baseBP + 20)
            case 2 :
                tv[2] = Math.floor((((a[0] + 10) * 2 + a[1] * 27 + a[2] * 3 + a[3] * 3 + a[4] * 2) / 10) * baseBP + 20)
            case 3 :
                tv[3] = Math.floor((((a[0] + 10) * 2 + a[1] * 3 + a[2] * 30 + a[3] * 3 + a[4] * 2) / 10) * baseBP + 20)
            default:
                tv[4] = Math.floor((((a[0] + 10) * 1 + a[1] * 2 + a[2] * 2 + a[3] * 20 + a[4] * 1) / 10) * baseBP + 20)
        }
    }
    tv[5] = Math.floor(((-(a[0] + te) * 3 - (a[1] + 4 + 10 - te) + a[2] * 2 - (a[3] + 4) + a[4] * 8) / 10) * baseBP + 100)
    tv[6] = Math.floor(((a[0] * 8 - (a[1] + 4 + 10 - te) - (a[2] + 4) + a[3] * 2 - (a[4] + 4 + te) * 3) / 10) * baseBP + 100)
    for (var k = 7; k < 12; k++) tv[k] = Math.floor(a[k - 7] * baseBP)
    for (var k = 12; k < 17; k++) tv[k] = Math.floor(stat(k - 12, a[0] + 2, a[1] + 2, a[2] + 2, a[3] + 2, a[4] + 2) * baseBP + 20)
    tv[17] = Math.floor(((-(a[0] + 2) * 3 - (a[1] + 2) + (a[2] + 2) * 2 - (a[3] + 2) * 1 + (a[4] + 2) * 8) / 10) * baseBP + 100)
    tv[18] = Math.floor((((a[0] + 2) * 8 - (a[1] + 2) - (a[2] + 2) + (a[3] + 2) * 2 - (a[4] + 2) * 3) / 10) * baseBP + 100)
    for (var k = 19; k < 24; k++) tv[k] = Math.floor((a[k - 19] + 2) * baseBP)
    return
}

function checkCell(list, target) {
    var startNum = 0
    var endNum = 0
    var color = 0
    if (list == "ptAllocCellA") {
        endNum = 6
        color = 4
        if (target != 0) document.getElementById("ptAllocCellB" + target).childNodes[0].disabled = true
    } else if (list == "ptAllocCellB") {
        endNum = 6
        color = 5
    }
    var cell = document.getElementById(list + "0")
    for (var i = startNum; i < endNum; i++) {
        cell = document.getElementById(list + i)
        cell.bgColor = colors[0]
    }
    cell = document.getElementById(list + target)
    cell.bgColor = colors[color]
    cell.childNodes[0].checked = true
    return
}

function setRanBpButton(set) {
    var row = 0
    for (var i = 1; i < 6; i++) {
        row = document.getElementById("row" + i)
        for (var j = 7; j < 18; j++) row.childNodes[j].bgColor = colors[0]
        row.childNodes[7 + set[i - 1]].bgColor = colors[2]
        row.childNodes[7 + set[i - 1]].childNodes[0].checked = true
    }
    updateBpAllocSum()
}

function selectCell(ref) {
    var sender = event.srcElement
    var cell = sender.parentNode
    var row = cell.parentNode
    if (sender.name.substring(0, 2) == "BP") {
        for (var i = 1; i < 6; i++) row.childNodes[i].bgColor = colors[0]
        cell.bgColor = "#99FFCC"
    } else if (sender.name.substring(0, 3) == "ran") {
        if (sender.value == 10) {
            for (var i = 1; i < 6; i++) {
                row = document.getElementById("row" + i)
                row.childNodes[7].bgColor = colors[2]
                row.childNodes[7].childNodes[0].checked = true
                for (var j = 8; j < 18; j++) row.childNodes[j].bgColor = colors[0]
            }
            cell.bgColor = colors[2]
            cell.parentNode.childNodes[7].bgColor = colors[0]
            sender.checked = true
        } else {
            for (var i = 7; i < 18; i++) row.childNodes[i].bgColor = colors[0]
            cell.bgColor = colors[2]
        }
    } else if (sender.name.substring(0, 3) == "sim") {
        for (var i = 19; i < 25; i++) row.childNodes[i].bgColor = colors[0]
        cell.bgColor = "#CCCCFF"
    } else if (sender.name == "ptAllocA") {
        enablePtAlloc("B")
        if (sender.value != 0 && document.getElementById("ptAllocCellB" + sender.value).childNodes[0].checked) checkCell("ptAllocCellB", 0)
        checkCell("ptAllocCellA", sender.value)
    } else if (sender.name == "ptAllocB") checkCell("ptAllocCellB", sender.value)
    updateBpAllocSum()
    return
}

function updateToLv() {
    if (!isNaN(parseInt(choose.setToLv.value))) {
        var num = (choose.setToLv.value * 1) % 1000
        choose.toLvDigit0.value = Math.floor(num / 100)
        choose.toLvDigit1.value = Math.floor(num / 10) % 10
        choose.toLvDigit2.value = num % 10
    }
    updateBpAllocSum()
    return
}

function incrementToLvByTimer() {
    if (toLvTimerStop) return
    var num = parseInt(choose.toLvDigit0.value * 100) + parseInt(choose.toLvDigit1.value * 10) + parseInt(choose.toLvDigit2.value)
    if (toLvTimerDir == "up") num = (num + 1) % 1000
    else num = (num + 999) % 1000
    choose.toLvDigit0.value = Math.floor(num / 100)
    choose.toLvDigit1.value = Math.floor(num / 10) % 10
    choose.toLvDigit2.value = num % 10
    toLvTimer++
    if (toLvTimer < 10) setTimeout("incrementToLvByTimer()", 250)
    else if (toLvTimer < 20) setTimeout("incrementToLvByTimer()", 125)
    else if (toLvTimer < 30) setTimeout("incrementToLvByTimer()", 62)
    else setTimeout("incrementToLvByTimer()", 30)
    updateBpAllocSum()
    return
}

function incrementUserDefinedBp(num) {
    if (toLvTimerStop) return
    if (document.getElementById("userDefinedBp1").disabled) return
    if (isNaN(parseInt(choose.ptLevel.value))) return
    for (var i = 1; i < 6; i++) {
        eval("if(isNaN(parseInt(choose.userDefinedBp" + i + ".value)))" + "{choose.userDefinedBp" + i + ".value=0}")
    }
    var lvDiff = parseInt(choose.toLvDigit0.value * 100) + parseInt(choose.toLvDigit1.value * 10) + parseInt(choose.toLvDigit2.value) - parseInt(choose.ptLevel.value)
    var bpSum = 0
    for (var i = 1; i < 6; i++) eval("bpSum+=parseInt(choose.userDefinedBp" + i + ".value)")
    if (toLvTimerDir == "up" && bpSum >= lvDiff) return
    else if (toLvTimerDir == "up") eval("choose.userDefinedBp" + num + ".value=parseInt(choose.userDefinedBp" + num + ".value) + 1")
    else if (toLvTimerDir == "down") {
        eval("var v = choose.userDefinedBp" + num + ".value")
        if (bpSum > lvDiff) v = Math.max(lvDiff - (bpSum - v), 0)
        else v = Math.max(v - 1, 0)
        eval("choose.userDefinedBp" + num + ".value=" + v)
    }
    toLvTimer++
    updateBpAllocSum()
    if (toLvTimer < 10) setTimeout("incrementUserDefinedBp(" + num + ")", 250)
    else if (toLvTimer < 20) setTimeout("incrementUserDefinedBp(" + num + ")", 125)
    else if (toLvTimer < 30) setTimeout("incrementUserDefinedBp(" + num + ")", 62)
    else setTimeout("incrementUserDefinedBp(" + num + ")", 30)
    return
}

function stopTimer() {
    toLvTimerStop = true
    toLvTimer = 0
    return
}

function toLvTimerIn(dir) {
    toLvTimerStop = false
    toLvTimerDir = dir
    incrementToLvByTimer()
}

function userDefinedBpIn(num, dir) {
    toLvTimerStop = false
    toLvTimerDir = dir
    incrementUserDefinedBp(num)
}

function toLvDigitTimer(num) {
    if (toLvTimerStop) return
    var target = eval("choose.toLvDigit" + num)
    if (toLvTimerDir == "up") target.value = (target.value * 1 + 1) % 10
    else target.value = (target.value * 1 + 9) % 10
    updateBpAllocSum()
    setTimeout("toLvDigitTimer(" + num + ")", 250)
}

function toLvDigitTimerIn(dir, num) {
    toLvTimerStop = false
    toLvTimerDir = dir
    toLvDigitTimer(num)
}

function selBpDrop(num) {
    for (var n = 1; n < 6; n++) {
        eval("choose.BP" + n + "[" + num + "].checked=true")
        eval("var row=document.getElementById('row" + n + "')")
        for (var i = 1; i < 6; i++) row.childNodes[i].bgColor = colors[0]
        row.childNodes[num + 1].bgColor = "#99FFCC"
    }
    updateBpAllocSum()
    return
}

function toggleBpAlloc() {
    var state = choose.bpAlloc.value
    if (state == bpAllocState[0]) choose.bpAlloc.value = bpAllocState[1]
    else if (state == bpAllocState[1]) {
        choose.bpAlloc.value = bpAllocState[2]
        for (var i = 1; i < 6; i++) document.getElementById("userDefinedBp" + i).disabled = false
        for (var i = 0; i < 6; i++) document.getElementById("ptAllocCellA" + i).childNodes[0].disabled = true
        for (var i = 0; i < 6; i++) document.getElementById("ptAllocCellB" + i).childNodes[0].disabled = true
    } else {
        choose.bpAlloc.value = bpAllocState[0]
        for (var i = 1; i < 6; i++) document.getElementById("userDefinedBp" + i).disabled = true
        enablePtAlloc("A")
        enablePtAlloc("B")
        for (var i = 0; i < 6; i++) {
            if (i != 0 && document.getElementById("ptAllocCellA" + i).childNodes[0].checked) document.getElementById("ptAllocCellB" + i).childNodes[0].disabled = true
        }
    }
    updateBpAllocSum()
    return
}

function enablePtAlloc(set) {
    for (var i = 0; i < 6; i++) document.getElementById("ptAllocCell" + set + i).childNodes[0].disabled = false
}

function ptAllocButton(num) {
    var state = choose.bpAlloc.value
    if (state == bpAllocState[0] || state == bpAllocState[1]) {
        enablePtAlloc("B")
        checkCell("ptAllocCellA", num)
        if (num == 0) checkCell("ptAllocCellB", 0)
        else if (num == 1) checkCell("ptAllocCellB", 3)
        else if (num == 2) checkCell("ptAllocCellB", 4)
        else if (num == 3) checkCell("ptAllocCellB", 1)
        else if (num == 4) checkCell("ptAllocCellB", 2)
        else checkCell("ptAllocCellB", 3)
    } else {
        if (num == 0) for (var i = 1; i < 6; i++) eval("choose.userDefinedBp" + i + ".value=0")
        else if (choose.userDefinedBp0.value > 0) eval("choose.userDefinedBp" + num + ".value=choose.userDefinedBp" + num + ".value*1+" + choose.userDefinedBp0.value)
        else eval("choose.userDefinedBp" + num + ".value=Math.max(choose.userDefinedBp" + num + ".value*1+" + choose.userDefinedBp0.value + ",0)")
    }
    updateBpAllocSum()
    return
}

function updateBpAllocSum() {
    if (isNaN(parseInt(choose.ptLevel.value))) return
    if (classCalcOpen) return
    for (var i = 1; i < 6; i++) eval("if(isNaN(parseInt(choose.userDefinedBp" + i + ".value)))" + "{choose.userDefinedBp" + i + ".value=0}")
    var lvDiff = parseInt(choose.toLvDigit0.value * 100) + parseInt(choose.toLvDigit1.value * 10) + parseInt(choose.toLvDigit2.value) - parseInt(choose.ptLevel.value)
    var bpSum = 0
    for (var i = 1; i < 6; i++) eval("bpSum+=parseInt(choose.userDefinedBp" + i + ".value)")
    choose.userDefinedBp0.value = (lvDiff - bpSum)
    simCollectNumbers()
    if (!simCheck()) return
    simCalculateInitial()
    simCalculateGrowth()

    var state = 0
    var mainBp = 0
    var subBp = 0
    for (var i = 0; i < 3; i++) if (choose.bpAlloc.value == bpAllocState[i]) state = i
    for (var i = 0; i < 6; i++) {
        if (document.getElementById("ptAllocCellA" + i).childNodes[0].checked) mainBp = i
        if (document.getElementById("ptAllocCellB" + i).childNodes[0].checked) subBp = i
    }
    if (mainBp == 0) mainBp = 6
    if (subBp == 0) subBp = 6
    simCalculateBpAlloc(state, mainBp - 1, subBp - 1)
    simCalculateFinal()
    simOutput(state, mainBp - 1, subBp - 1)
    return
}

function simChangePrecision(num) {
    simOutputPrecision = num
    updateBpAllocSum()
}

function simCollectNumbers() {
    for (var i = 1; i < 6; i++) {
        for (var j = 0; j < 5; j++) if (document.getElementById("BP" + i + j).childNodes[0].checked) simBpDrop[i - 1] = j
        for (var j = 0; j < 11; j++) if (document.getElementById("ranBP" + i + j).childNodes[0].checked) simRanBp[i - 1] = j
        simPt[i - 1] = parseInt(document.getElementById("userDefinedBp" + i).value)
    }
    for (var i = 0; i < 6; i++) if (document.getElementById("simGrowthInput" + i).childNodes[0].checked) simGrowth = i
    toLv = parseInt(choose.toLvDigit0.value * 100) + parseInt(choose.toLvDigit1.value * 10) + parseInt(choose.toLvDigit2.value)
    return
}

function simCheck() {
    ranBpSum = 0
    for (var i = 0; i < 5; i++) ranBpSum += simRanBp[i]
    if (ranBpSum != 10 || (document.getElementById("userDefinedBp0").value < 0 && choose.bpAlloc.value == bpAllocState[2]) || toLv < level) {
        helpMessage()
        return false
    }
    preCalSetup()
    helpMessage()
    if (ptType == undefined || ptType == -1) return false
    return true
}

function simCalculateInitial() {
    for (var i = 0; i < 5; i++) initialBp[i] = (base + (40 + simGrowth) / 1000 * (level - 1)) * (Pts[ptType][3 + i] - simBpDrop[i] + simRanBp[i])
    return
}

function simCalculateGrowth() {
    for (var i = 0; i < 5; i++) {
        var n = calClass(Pts[ptType][3 + i] - simBpDrop[i])
        growthBp[i] = (toLv - level) * n
    }
}

function simCalculateBpAlloc(state, mainBp, subBp) {
    var lvDiff = toLv - level
    var limit = lvDiff
    for (var i = 0; i < 5; i++) limit += initialBp[i] + growthBp[i]
    limit = limit / 2
    for (var i = 0; i < 5; i++) allocBp[i] = 0

    if (state == 0) {
        if (mainBp == 5) for (var i = 0; i < 5; i++) allocBp[i] = 0
        else if ((initialBp[mainBp] + growthBp[mainBp] + lvDiff) > limit) {
            allocBp[mainBp] = Math.floor(limit - (initialBp[mainBp] + growthBp[mainBp]))
            allocBp[subBp] = lvDiff - allocBp[mainBp]
        } else allocBp[mainBp] = lvDiff
    } else if (state == 1) {
        var half = Math.ceil(lvDiff / 2)
        if (mainBp == 5) for (var i = 0; i < 5; i++) allocBp[i] = 0
        else if ((initialBp[mainBp] + growthBp[mainBp] + half) > limit) {
            simCalculateBpAlloc(0, mainBp, subBp)
            return
        } else {
            allocBp[mainBp] = half
            allocBp[subBp] = lvDiff - half
        }
    } else {
        for (var i = 0; i < 5; i++) {
            if ((initialBp[i] + growthBp[i] + simPt[i]) > limit) {
                printTo('helpText', '這樣的配點方式會導致爆點, 請分配<font color=red><B>' + Math.floor(limit - (initialBp[i] + growthBp[i])) + '</B></font>以下的點數在<B>' + BPNameList[i] + '</B>.')
                return
            }
            allocBp[i] = simPt[i]
        }
    }
    return
}

function simCalculateFinal() {
    for (var i = 0; i < 5; i++) finalBp[i] = initialBp[i] + growthBp[i] + allocBp[i]
}

function toPrecision(num, precision) {
    if (precision == 0) return Math.floor(num)
    else return num.toFixed(precision)
}

function simOutput(state, mainBp, subBp) {
    var precision = simOutputPrecision
    var initialStat = new Array(0, 0, 0, 0, 0, 0, 0)
    var finalStat = new Array(0, 0, 0, 0, 0, 0, 0)
    var dropSum = 0
    allocBp[5] = toLv - level
    for (var i = 0; i < 5; i++) allocBp[5] -= allocBp[i]
    for (var i = 0; i < 5; i++) initialStat[i] = toPrecision(stat(i, initialBp) + 20, precision)
    initialStat[5] = toPrecision(spi(initialBp) + 100, precision)
    initialStat[6] = toPrecision(rev(initialBp) + 100, precision)
    for (var i = 0; i < 7; i++) simCompareSourceI[i] = toPrecision(initialStat[i], 0)
    for (var i = 0; i < 5; i++) simCompareSourceI[i + 7] = toPrecision(initialBp[i], 0)
    for (var i = 0; i < 5; i++) finalStat[i] = toPrecision(stat(i, finalBp) + 20, precision)
    finalStat[5] = toPrecision(spi(finalBp) + 100, precision)
    finalStat[6] = toPrecision(rev(finalBp) + 100, precision)
    for (var i = 0; i < 7; i++) simCompareSourceF[i] = toPrecision(finalStat[i], 0)
    for (var i = 0; i < 5; i++) simCompareSourceF[i + 7] = toPrecision(finalBp[i], 0)
    var x = '<B>' + name + '</B> ' + level + '->' + toLv + '級成長模擬,'
    for (var i in BPNameList) x += ' ' + BPNameList[i] + '掉<font color=red>' + simBpDrop[i] + '</font>'
    for (var i = 0; i < 5; i++) dropSum += simBpDrop[i]
    x += '檔, 共掉' + dropSum + '檔, 隨機檔('
    for (var i = 0; i < 4; i++) x += simRanBp[i] + ','
    x += simRanBp[4] + ')'
    if (level != 1) x += ', 成長係數 ' + simGrowth
    x += '<BR><B>配點: </B>'
    if (mainBp == 5 && state != 2) x += '未分配'
    else if (state == 0) {
        if (allocBp[mainBp] == (toLv - level)) x += '全加' + BPNameList[mainBp]
        else if (subBp == 5) x += BPNameList[mainBp] + '爆保留. (' + BPNameList[mainBp] + allocBp[mainBp] + ', 餘' + allocBp[5] + '點未分配)'
        else x += BPNameList[mainBp] + '爆加' + BPNameList[subBp] + '. (' + BPNameList[mainBp] + allocBp[mainBp] + ', ' + BPNameList[subBp] + allocBp[subBp] + ')'
    } else if (state == 1) {
        if (subBp == 5) x += '加' + BPNameList[mainBp] + '/保留一半點數. (' + BPNameList[mainBp] + allocBp[mainBp] + ', 餘' + allocBp[5] + '點未分配)'
        else x += BPNameList[mainBp] + BPNameList[subBp] + '混加. (' + BPNameList[mainBp] + allocBp[mainBp] + ', ' + BPNameList[subBp] + allocBp[subBp] + ')'
    } else {
        x += ' '
        for (var i = 0; i < 5; i++) x += BPNameList[i] + allocBp[i] + ' '
        x += '餘' + allocBp[5] + '點未分配.'
    }
    x += '<TABLE border=0 bordercolor="#00CCFF"><TR><TD></TD>'
    for (var i in statNameList) {
        if (i == 5) x += '<TD align="right"></TD>'
        x += '<TH align="right">' + statNameList[i] + '</TH>'
    }
    x += '<TD></TD>'
    for (var i in BPNameList) x += '<TH align="right">' + BPNameList[i] + '</TH>'
    x += '</TR><TR align="right"><TH>' + level + '級預測能力</TH>'
    for (var i = 0; i < 5; i++) x += '<TD>' + initialStat[i] + '</TD>'
    x += '<TD></TD>'
    for (var i = 5; i < 7; i++) x += '<TD>' + initialStat[i] + '</TD>'
    x += '<TD></TD>'
    for (var i = 0; i < 5; i++) x += '<TD>' + toPrecision(initialBp[i], precision) + '</TD>'
    if (simCompare) {
        x += '<TR align="right"><TH align="right"><INPUT TYPE="button" value="' + level + '級實際能力" CLASS="simPrompt" onClick="simPromptStat(\'initial\')"></TH>'
        for (var i = 0; i < 12; i++) {
            x += '<TD><INPUT CLASS="simCompare" TYPE="text" id="simCompareI' + i + '" NAME="simCompareI' + i + '" VALUE=' + simFilterValue(realInitial[i]) + ' onChange="simCompareDiff()" size=5 maxlength=5></TD>'
            if (i == 4 || i == 6) x += '<TD></TD>'
        }
        x += '</TR><TR align="right"><TH>差異</TH>'
        for (var i = 0; i < 12; i++) {
            x += '<TD><INPUT CLASS="simDiff" TYPE="text" readonly id="simDiffI' + i + '" NAME="simDiffI' + i + '" VALUE="" size=5 maxlength=5></TD>'
            if (i == 4 || i == 6) x += '<TD></TD>'
        }
        x += '<TH>總誤差:</TH><TD><INPUT CLASS="simDiff" TYPE="text" readonly id="simDiffSumI" NAME="simDiffSumI" VALUE="" size=6 maxlength=6></TD>'
    }
    x += '</TR><TR align="right"><TH>' + toLv + '級預測能力</TH>'
    for (var i = 0; i < 5; i++) x += '<TD>' + finalStat[i] + '</TD>'
    x += '<TD></TD>'
    for (var i = 5; i < 7; i++) x += '<TD>' + finalStat[i] + '</TD>'
    x += '<TD></TD>'
    for (var i = 0; i < 5; i++) x += '<TD>' + toPrecision(finalBp[i], precision) + '</TD>'
    if (simCompare) {
        x += '<TR align="right"><TH align="right"><INPUT TYPE="button" value="' + toLv + '級實際能力" CLASS="simPrompt" onClick="simPromptStat(\'final\')"></TH>'
        for (var i = 0; i < 12; i++) {
            x += '<TD align="right"><INPUT CLASS="simCompare" TYPE="text" id="simCompareF' + i + '" NAME="simCompareF' + i + '" VALUE=' + simFilterValue(realFinal[i]) + ' onChange="simCompareDiff()" size=5 maxlength=5></TD>'
            if (i == 4 || i == 6) x += '<TD></TD>'
        }
        x += '</TR><TR align="right"><TH>差異</TH>'
        for (var i = 0; i < 12; i++) {
            x += '<TD><INPUT CLASS="simDiff" TYPE="text" readonly id="simDiffF' + i + '" NAME="simDiffF' + i + '" VALUE="" size=5 maxlength=5></TD>'
            if (i == 4 || i == 6) x += '<TD></TD>'
        }
        x += '<TH>總誤差:</TH><TD><INPUT CLASS="simDiff" TYPE="text" readonly id="simDiffSumF" NAME="simDiffSumF" VALUE="" size=6 maxlength=6></TD>'
    }
    x += '</TR></TABLE><HR NOSHADE COLOR="#400080">'
    simOutputText = x
    printTo('simOutput', simOutputText)
    if (simCompare) simCompareDiff()
}

function simCompareDiff() {
    var simDiffSumI = 0
    var simDiffSumF = 0
    for (var i = 0; i < 12; i++) {
        var num = document.getElementById("simCompareI" + i).value
        if (num == undefined || isNaN(parseInt(num))) {
            num = ""
            document.getElementById("simDiffI" + i).value = ""
            ranCompare[i] = false
        } else {
            document.getElementById("simDiffI" + i).value = simCompareSourceI[i] - num
            simDiffSumI += Math.abs(document.getElementById("simDiffI" + i).value)
            ranCompare[i] = true
        }
        realInitial[i] = num
        num = document.getElementById("simCompareF" + i).value
        if (num == undefined || isNaN(parseInt(num))) {
            num = ""
            document.getElementById("simDiffF" + i).value = ""
            ranCompare[12 + i] = false
        } else {
            document.getElementById("simDiffF" + i).value = simCompareSourceF[i] - num
            simDiffSumF += Math.abs(document.getElementById("simDiffF" + i).value)
            ranCompare[12 + i] = true
        }
        realFinal[i] = num
    }
    document.getElementById("simDiffSumI").value = simDiffSumI
    document.getElementById("simDiffSumF").value = simDiffSumF
}

function simFilterValue(num) {
    if (num == undefined) return '""'
    else if (isNaN(parseInt(num))) return '""'
    else return parseInt(num)
}

function clearSimOutput() {
    if (simOutputText == '') updateBpAllocSum()
    else {
        printTo('simOutput', '')
        printTo('simOutput2', '')
        simOutputText = ''
        simOutputText2 = ''
    }
}

function simStick() {
    if (simCompare && simOutputText != '') {
        simCompare = false
        updateBpAllocSum()
        simOutputText2 = simOutputText + simOutputText2
        simCompare = true
        updateBpAllocSum()
    } else simOutputText2 = simOutputText + simOutputText2
    printTo('simOutput2', simOutputText2)
}

function simPromptStat(target) {
    var lastLine = ""
    var line = ""
    var tempStat = new Array(12)
    if (target == "initial") for (var i = 0; i < 12; i++) tempStat[i] = realInitial[i]
    else for (var i = 0; i < 12; i++) tempStat[i] = realFinal[i]
    if (tempStat[0] != undefined && tempStat[0] >= 20) for (var i in tempStat) lastLine += tempStat[i] + ' '
    if (target == "initial") var lv = level
    else var lv = toLv
    line = prompt('請以血魔攻防敏 精回 體力強速魔順序輸入欲比對的' + lv + '級能力資料', lastLine)
    if (line == undefined || line == lastLine) return
    line = line.split(/[^0-9#]/)
    if (line.length > 5 && line[0] < 20 && line[1] > 20) line.shift()
    var len = line.length
    if (line[0] == undefined || len < 5) return
    tempStat = new Array(12)
    for (var i = 0; i < 5; i++) tempStat[i] = line[i]
    if (len > 5 && len < 10) {
        tempStat[5] = line[5]
        if (len > 6) tempStat[6] = line[6]
    }
    if (len >= 10) {
        var move = Math.min(len - 10, 2) + 5
        if (len == 11 || len == 12) {
            var sum = 0
            for (var j = (len - 6); j < (len - 1); j++) sum += line[move + j]
            if (sum == line[len - 1]) move--
            else if (line[5] > 20) {
                tempStat[5] = line[5]
                if (len == 12) tempStat[6] = line[6]
            } else {
                move -= (len - 10)
            }
        }
        if (len > 11 && line[5] > 20) tempStat[5] = line[5]
        if (len > 12 && line[6] > 20) tempStat[6] = line[6]
        for (var b = 0; b < 5; b++) tempStat[7 + b] = line[b + move]
    }
    if (target == "initial") for (var i = 0; i < 12; i++) {
        realInitial[i] = tempStat[i]
        document.getElementById("simCompareI" + i).value = ""
        if (tempStat[i] != undefined && !isNaN(tempStat[i])) document.getElementById("simCompareI" + i).value = tempStat[i]
    }
    else for (var i = 0; i < 12; i++) {
        realFinal[i] = tempStat[i]
        document.getElementById("simCompareF" + i).value = ""
        if (tempStat[i] != undefined && !isNaN(tempStat[i])) document.getElementById("simCompareF" + i).value = tempStat[i]
    }
    simCompareDiff()
    return
}

function simToggleCompare() {
    simCompare = !simCompare
    updateBpAllocSum()
}

function calClass(num) {
    if (num == 0) return 0
    else return (num * 0.04 + (Math.floor(num / 5) + Math.floor((num - 1) / 5)) * 0.005).toPrecision(3)
}

function ranFindBest() {
    if (!simCompare) return
    simCompareDiff()
    bestRanSet = new Array(2, 2, 2, 2, 2)
    bestRanDiff = 9999999
    var initialStat = new Array()
    var finalStat = new Array()
    var initialSet = new Array()
    var finalSet = new Array()
    var ranLoopVal = new Array()
    var ranLoopBase = new Array()
    for (var i = 0; i < 5; i++) {
        ranLoopBase[i] = new Array()
        initialSet[i] = initialBp[i] - (base + (40 + simGrowth) / 1000 * (level - 1)) * simRanBp[i]
        finalSet[i] = finalBp[i] - (base + (40 + simGrowth) / 1000 * (level - 1)) * simRanBp[i]
    }
    for (var i = 0; i < 5; i++) {
        initialStat[i] = stat(i, initialSet) + 20
        finalStat[i] = stat(i, finalSet) + 20
    }
    initialStat[5] = spi(initialSet) + 100
    initialStat[6] = rev(initialSet) + 100
    finalStat[5] = spi(finalSet) + 100
    finalStat[6] = rev(finalSet) + 100
    for (var i = 7; i < 12; i++) initialStat[i] = initialSet[i - 7]
    for (var i = 7; i < 12; i++) finalStat[i] = finalSet[i - 7]
    for (var i = 0; i < 12; i++) if (ranCompare[i]) ranDiffVal[i] = initialStat[i] - realInitial[i] - 0.5
    for (var i = 0; i < 12; i++) if (ranCompare[12 + i]) ranDiffVal[12 + i] = finalStat[i] - realFinal[i] - 0.5
    for (var i = 0; i < 5; i++) {
        var tempSet = new Array(0, 0, 0, 0, 0)
        tempSet[i] = base
        for (var j = 0; j < 5; j++) ranLoopBase[i][j] = stat(j, tempSet)
        ranLoopBase[i][5] = spi(tempSet)
        ranLoopBase[i][6] = rev(tempSet)
    }
    for (var a = 0; a < 11; a++) {
        ranLoopVal[7] = a * base
        for (var b = 0; b < 11 - a; b++) {
            ranLoopVal[8] = b * base
            for (var c = 0; c < 11 - a - b; c++) {
                ranLoopVal[9] = c * base
                for (var d = 0; d < 11 - a - b - c; d++) {
                    ranLoopVal[10] = d * base
                    e = 10 - a - b - c - d
                    ranLoopVal[11] = e * base
                    for (var i = 0; i < 7; i++) ranLoopVal[i] = a * ranLoopBase[0][i] + b * ranLoopBase[1][i] + c * ranLoopBase[2][i] + d * ranLoopBase[3][i] + e * ranLoopBase[4][i]
                    var ranDiff = 0
                    var initialDiff = 0
                    //調整-0.00001以解決js在減法部份的問題, 否則誤差會被高估
                    for (var i = 0; i < 12; i++) if (ranCompare[i]) ranDiff += Math.round(Math.abs(ranLoopVal[i] + ranDiffVal[i]) - 0.00001)
                    initialDiff = ranDiff
                    for (var i = 12; i < 24; i++) if (ranCompare[i]) ranDiff += Math.round(Math.abs(ranLoopVal[i - 12] + ranDiffVal[i]) - 0.00001)
                    //如總誤差相同, 取最後一筆起始能力誤差為0的隨機檔組合
                    if (ranDiff < bestRanDiff || (ranDiff == bestRanDiff && initialDiff == 0)) {
                        bestRanSet = new Array(a, b, c, d, e)
                        bestRanDiff = ranDiff
                    }
                }
            }
        }
    }
    setRanBpButton(bestRanSet)
}

function filterPet(name) {
    name = $.trim(name);
    $("[name=raceMenu]")[0].selectedIndex = 0;
    $("[name=raceMenu]").change();

    var options = $(".petMenu option");
    for (var i = 0; i < options.length; ++i) {
        options[i].style.display = '';
        options[i].disabled = false;
    }

    if ($.trim(name) == "") {
        return false;
    }

    var selected = options.filter(n => {
        const res = options[n].text && options[n].text.indexOf(name) == -1
        return res;
    });


    for (var i = 0; i < selected.length; ++i) {
        selected[i].style.display = 'none';
        selected[i].disabled = true;
    }

    var existing = options.filter(n => !options[n].disabled);
    if (existing.length) {
        $(".petMenu").val(existing[0].value).change();
    }


}